// Code generated by "weaver generate". DO NOT EDIT.
//go:build !ignoreWeaverGen

package main

import (
	"context"
	"errors"
	"fmt"
	"github.com/ServiceWeaver/weaver"
	"github.com/ServiceWeaver/weaver/runtime/codegen"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
	"reflect"
)

func init() {
	codegen.Register(codegen.Registration{
		Name:  "SocialNetwork/server/BackendServicer",
		Iface: reflect.TypeOf((*BackendServicer)(nil)).Elem(),
		Impl:  reflect.TypeOf(BackendService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return backendServicer_local_stub{impl: impl.(BackendServicer), tracer: tracer, compostPostMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "CompostPost", Remote: false}), followMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "Follow", Remote: false}), followWithUsernameMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "FollowWithUsername", Remote: false}), getFolloweesMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "GetFollowees", Remote: false}), getFollowersMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "GetFollowers", Remote: false}), getMediaMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "GetMedia", Remote: false}), loginMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "Login", Remote: false}), readHomeTimelineMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "ReadHomeTimeline", Remote: false}), readUserTimelineMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "ReadUserTimeline", Remote: false}), registerUserMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "RegisterUser", Remote: false}), registerUserWithIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "RegisterUserWithId", Remote: false}), removePostsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "RemovePosts", Remote: false}), unfollowMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "Unfollow", Remote: false}), unfollowWithUsernameMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "UnfollowWithUsername", Remote: false}), uploadMediaMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "UploadMedia", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return backendServicer_client_stub{stub: stub, compostPostMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "CompostPost", Remote: true}), followMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "Follow", Remote: true}), followWithUsernameMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "FollowWithUsername", Remote: true}), getFolloweesMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "GetFollowees", Remote: true}), getFollowersMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "GetFollowers", Remote: true}), getMediaMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "GetMedia", Remote: true}), loginMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "Login", Remote: true}), readHomeTimelineMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "ReadHomeTimeline", Remote: true}), readUserTimelineMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "ReadUserTimeline", Remote: true}), registerUserMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "RegisterUser", Remote: true}), registerUserWithIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "RegisterUserWithId", Remote: true}), removePostsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "RemovePosts", Remote: true}), unfollowMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "Unfollow", Remote: true}), unfollowWithUsernameMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "UnfollowWithUsername", Remote: true}), uploadMediaMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/BackendServicer", Method: "UploadMedia", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return backendServicer_server_stub{impl: impl.(BackendServicer), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return backendServicer_reflect_stub{caller: caller}
		},
		RefData: "⟦676f096e:wEaVeReDgE:SocialNetwork/server/BackendServicer→SocialNetwork/server/UserServicer⟧\n⟦f87e7ca2:wEaVeReDgE:SocialNetwork/server/BackendServicer→SocialNetwork/server/IUserTimelineService⟧\n⟦230e4fdc:wEaVeReDgE:SocialNetwork/server/BackendServicer→SocialNetwork/server/ISocialGraphService⟧\n⟦5f5491db:wEaVeReDgE:SocialNetwork/server/BackendServicer→SocialNetwork/server/PostStorageServicer⟧\n⟦0e49efff:wEaVeReDgE:SocialNetwork/server/BackendServicer→SocialNetwork/server/IHomeTimelineService⟧\n⟦4bf2ebc2:wEaVeReDgE:SocialNetwork/server/BackendServicer→SocialNetwork/server/IUrlShortenService⟧\n⟦0d65c789:wEaVeReDgE:SocialNetwork/server/BackendServicer→SocialNetwork/server/ITextService⟧\n⟦be87b33f:wEaVeReDgE:SocialNetwork/server/BackendServicer→SocialNetwork/server/IUniqueIdService⟧\n⟦4b1af254:wEaVeReDgE:SocialNetwork/server/BackendServicer→SocialNetwork/server/MediaStorageServicer⟧\n⟦968417fa:wEaVeReDgE:SocialNetwork/server/BackendServicer→SocialNetwork/server/IMediaService⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:  "SocialNetwork/server/IHomeTimelineService",
		Iface: reflect.TypeOf((*IHomeTimelineService)(nil)).Elem(),
		Impl:  reflect.TypeOf(HomeTimelineService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return iHomeTimelineService_local_stub{impl: impl.(IHomeTimelineService), tracer: tracer, readHomeTimelineMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IHomeTimelineService", Method: "ReadHomeTimeline", Remote: false}), removePostMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IHomeTimelineService", Method: "RemovePost", Remote: false}), writeHomeTimelineMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IHomeTimelineService", Method: "WriteHomeTimeline", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return iHomeTimelineService_client_stub{stub: stub, readHomeTimelineMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IHomeTimelineService", Method: "ReadHomeTimeline", Remote: true}), removePostMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IHomeTimelineService", Method: "RemovePost", Remote: true}), writeHomeTimelineMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IHomeTimelineService", Method: "WriteHomeTimeline", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return iHomeTimelineService_server_stub{impl: impl.(IHomeTimelineService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return iHomeTimelineService_reflect_stub{caller: caller}
		},
		RefData: "⟦7b07cd90:wEaVeReDgE:SocialNetwork/server/IHomeTimelineService→SocialNetwork/server/PostStorageServicer⟧\n⟦c27eaeb4:wEaVeReDgE:SocialNetwork/server/IHomeTimelineService→SocialNetwork/server/ISocialGraphService⟧\n⟦2ae5bf71:wEaVeReDgE:SocialNetwork/server/IHomeTimelineService→SocialNetwork/server/IStorage⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:  "SocialNetwork/server/IMediaService",
		Iface: reflect.TypeOf((*IMediaService)(nil)).Elem(),
		Impl:  reflect.TypeOf(MediaService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return iMediaService_local_stub{impl: impl.(IMediaService), tracer: tracer, composeMediaMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IMediaService", Method: "ComposeMedia", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return iMediaService_client_stub{stub: stub, composeMediaMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IMediaService", Method: "ComposeMedia", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return iMediaService_server_stub{impl: impl.(IMediaService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return iMediaService_reflect_stub{caller: caller}
		},
		RefData: "",
	})
	codegen.Register(codegen.Registration{
		Name:  "SocialNetwork/server/ISocialGraphService",
		Iface: reflect.TypeOf((*ISocialGraphService)(nil)).Elem(),
		Impl:  reflect.TypeOf(SocialGraphService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return iSocialGraphService_local_stub{impl: impl.(ISocialGraphService), tracer: tracer, followMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/ISocialGraphService", Method: "Follow", Remote: false}), followWithUsernameMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/ISocialGraphService", Method: "FollowWithUsername", Remote: false}), getFolloweesMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/ISocialGraphService", Method: "GetFollowees", Remote: false}), getFollowersMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/ISocialGraphService", Method: "GetFollowers", Remote: false}), unfollowMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/ISocialGraphService", Method: "Unfollow", Remote: false}), unfollowWithUsernameMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/ISocialGraphService", Method: "UnfollowWithUsername", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return iSocialGraphService_client_stub{stub: stub, followMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/ISocialGraphService", Method: "Follow", Remote: true}), followWithUsernameMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/ISocialGraphService", Method: "FollowWithUsername", Remote: true}), getFolloweesMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/ISocialGraphService", Method: "GetFollowees", Remote: true}), getFollowersMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/ISocialGraphService", Method: "GetFollowers", Remote: true}), unfollowMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/ISocialGraphService", Method: "Unfollow", Remote: true}), unfollowWithUsernameMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/ISocialGraphService", Method: "UnfollowWithUsername", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return iSocialGraphService_server_stub{impl: impl.(ISocialGraphService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return iSocialGraphService_reflect_stub{caller: caller}
		},
		RefData: "⟦2384019b:wEaVeReDgE:SocialNetwork/server/ISocialGraphService→SocialNetwork/server/IStorage⟧\n⟦5b500a3e:wEaVeReDgE:SocialNetwork/server/ISocialGraphService→SocialNetwork/server/UserServicer⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:   "SocialNetwork/server/IStorage",
		Iface:  reflect.TypeOf((*IStorage)(nil)).Elem(),
		Impl:   reflect.TypeOf(Storage{}),
		Routed: true,
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return iStorage_local_stub{impl: impl.(IStorage), tracer: tracer, followMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "Follow", Remote: false}), getFolloweesMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "GetFollowees", Remote: false}), getFollowersMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "GetFollowers", Remote: false}), getMediaDataMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "GetMediaData", Remote: false}), getPostMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "GetPost", Remote: false}), getPostTimelineMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "GetPostTimeline", Remote: false}), getShortenUrlMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "GetShortenUrl", Remote: false}), getUserProfileMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "GetUserProfile", Remote: false}), putMediaDataMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "PutMediaData", Remote: false}), putPostMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "PutPost", Remote: false}), putPostTimelineMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "PutPostTimeline", Remote: false}), putShortenUrlMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "PutShortenUrl", Remote: false}), putUserProfileMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "PutUserProfile", Remote: false}), removePostMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "RemovePost", Remote: false}), removePostTimelineMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "RemovePostTimeline", Remote: false}), removeShortenUrlMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "RemoveShortenUrl", Remote: false}), unfollowMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "Unfollow", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return iStorage_client_stub{stub: stub, followMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "Follow", Remote: true}), getFolloweesMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "GetFollowees", Remote: true}), getFollowersMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "GetFollowers", Remote: true}), getMediaDataMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "GetMediaData", Remote: true}), getPostMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "GetPost", Remote: true}), getPostTimelineMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "GetPostTimeline", Remote: true}), getShortenUrlMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "GetShortenUrl", Remote: true}), getUserProfileMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "GetUserProfile", Remote: true}), putMediaDataMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "PutMediaData", Remote: true}), putPostMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "PutPost", Remote: true}), putPostTimelineMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "PutPostTimeline", Remote: true}), putShortenUrlMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "PutShortenUrl", Remote: true}), putUserProfileMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "PutUserProfile", Remote: true}), removePostMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "RemovePost", Remote: true}), removePostTimelineMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "RemovePostTimeline", Remote: true}), removeShortenUrlMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "RemoveShortenUrl", Remote: true}), unfollowMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IStorage", Method: "Unfollow", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return iStorage_server_stub{impl: impl.(IStorage), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return iStorage_reflect_stub{caller: caller}
		},
		RefData: "",
	})
	codegen.Register(codegen.Registration{
		Name:  "SocialNetwork/server/ITextService",
		Iface: reflect.TypeOf((*ITextService)(nil)).Elem(),
		Impl:  reflect.TypeOf(TextService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return iTextService_local_stub{impl: impl.(ITextService), tracer: tracer, composeTextMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/ITextService", Method: "ComposeText", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return iTextService_client_stub{stub: stub, composeTextMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/ITextService", Method: "ComposeText", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return iTextService_server_stub{impl: impl.(ITextService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return iTextService_reflect_stub{caller: caller}
		},
		RefData: "⟦f30330ab:wEaVeReDgE:SocialNetwork/server/ITextService→SocialNetwork/server/IUrlShortenService⟧\n⟦6ef9efab:wEaVeReDgE:SocialNetwork/server/ITextService→SocialNetwork/server/IUserMentionService⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:  "SocialNetwork/server/IUniqueIdService",
		Iface: reflect.TypeOf((*IUniqueIdService)(nil)).Elem(),
		Impl:  reflect.TypeOf(UniqueIdService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return iUniqueIdService_local_stub{impl: impl.(IUniqueIdService), tracer: tracer, composeUniqueIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IUniqueIdService", Method: "ComposeUniqueId", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return iUniqueIdService_client_stub{stub: stub, composeUniqueIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IUniqueIdService", Method: "ComposeUniqueId", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return iUniqueIdService_server_stub{impl: impl.(IUniqueIdService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return iUniqueIdService_reflect_stub{caller: caller}
		},
		RefData: "",
	})
	codegen.Register(codegen.Registration{
		Name:  "SocialNetwork/server/IUrlShortenService",
		Iface: reflect.TypeOf((*IUrlShortenService)(nil)).Elem(),
		Impl:  reflect.TypeOf(UrlShortenService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return iUrlShortenService_local_stub{impl: impl.(IUrlShortenService), tracer: tracer, composeUrlMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IUrlShortenService", Method: "ComposeUrl", Remote: false}), getExtendedUrlsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IUrlShortenService", Method: "GetExtendedUrls", Remote: false}), removeUrlsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IUrlShortenService", Method: "RemoveUrls", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return iUrlShortenService_client_stub{stub: stub, composeUrlMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IUrlShortenService", Method: "ComposeUrl", Remote: true}), getExtendedUrlsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IUrlShortenService", Method: "GetExtendedUrls", Remote: true}), removeUrlsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IUrlShortenService", Method: "RemoveUrls", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return iUrlShortenService_server_stub{impl: impl.(IUrlShortenService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return iUrlShortenService_reflect_stub{caller: caller}
		},
		RefData: "⟦e39be756:wEaVeReDgE:SocialNetwork/server/IUrlShortenService→SocialNetwork/server/IStorage⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:  "SocialNetwork/server/IUserMentionService",
		Iface: reflect.TypeOf((*IUserMentionService)(nil)).Elem(),
		Impl:  reflect.TypeOf(UserMentionService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return iUserMentionService_local_stub{impl: impl.(IUserMentionService), tracer: tracer, composeUserMentionsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IUserMentionService", Method: "ComposeUserMentions", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return iUserMentionService_client_stub{stub: stub, composeUserMentionsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IUserMentionService", Method: "ComposeUserMentions", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return iUserMentionService_server_stub{impl: impl.(IUserMentionService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return iUserMentionService_reflect_stub{caller: caller}
		},
		RefData: "⟦b4fbfc1c:wEaVeReDgE:SocialNetwork/server/IUserMentionService→SocialNetwork/server/IStorage⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:  "SocialNetwork/server/IUserTimelineService",
		Iface: reflect.TypeOf((*IUserTimelineService)(nil)).Elem(),
		Impl:  reflect.TypeOf(UserTimelineService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return iUserTimelineService_local_stub{impl: impl.(IUserTimelineService), tracer: tracer, readUserTimelineMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IUserTimelineService", Method: "ReadUserTimeline", Remote: false}), removePostMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IUserTimelineService", Method: "RemovePost", Remote: false}), writeUserTimelineMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IUserTimelineService", Method: "WriteUserTimeline", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return iUserTimelineService_client_stub{stub: stub, readUserTimelineMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IUserTimelineService", Method: "ReadUserTimeline", Remote: true}), removePostMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IUserTimelineService", Method: "RemovePost", Remote: true}), writeUserTimelineMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/IUserTimelineService", Method: "WriteUserTimeline", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return iUserTimelineService_server_stub{impl: impl.(IUserTimelineService), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return iUserTimelineService_reflect_stub{caller: caller}
		},
		RefData: "⟦2cea09c0:wEaVeReDgE:SocialNetwork/server/IUserTimelineService→SocialNetwork/server/IStorage⟧\n⟦9a64454b:wEaVeReDgE:SocialNetwork/server/IUserTimelineService→SocialNetwork/server/PostStorageServicer⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:      "github.com/ServiceWeaver/weaver/Main",
		Iface:     reflect.TypeOf((*weaver.Main)(nil)).Elem(),
		Impl:      reflect.TypeOf(app{}),
		Listeners: []string{"compose_post", "remove_posts"},
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return main_local_stub{impl: impl.(weaver.Main), tracer: tracer}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any { return main_client_stub{stub: stub} },
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return main_server_stub{impl: impl.(weaver.Main), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return main_reflect_stub{caller: caller}
		},
		RefData: "⟦9906f744:wEaVeReDgE:github.com/ServiceWeaver/weaver/Main→SocialNetwork/server/BackendServicer⟧\n⟦076385ea:wEaVeRlIsTeNeRs:github.com/ServiceWeaver/weaver/Main→compose_post,remove_posts⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:  "SocialNetwork/server/MediaStorageServicer",
		Iface: reflect.TypeOf((*MediaStorageServicer)(nil)).Elem(),
		Impl:  reflect.TypeOf(MediaStorageService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return mediaStorageServicer_local_stub{impl: impl.(MediaStorageServicer), tracer: tracer, getMediaMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/MediaStorageServicer", Method: "GetMedia", Remote: false}), uploadMediaMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/MediaStorageServicer", Method: "UploadMedia", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return mediaStorageServicer_client_stub{stub: stub, getMediaMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/MediaStorageServicer", Method: "GetMedia", Remote: true}), uploadMediaMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/MediaStorageServicer", Method: "UploadMedia", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return mediaStorageServicer_server_stub{impl: impl.(MediaStorageServicer), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return mediaStorageServicer_reflect_stub{caller: caller}
		},
		RefData: "⟦68fe92df:wEaVeReDgE:SocialNetwork/server/MediaStorageServicer→SocialNetwork/server/IStorage⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:  "SocialNetwork/server/PostStorageServicer",
		Iface: reflect.TypeOf((*PostStorageServicer)(nil)).Elem(),
		Impl:  reflect.TypeOf(PostStorageService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return postStorageServicer_local_stub{impl: impl.(PostStorageServicer), tracer: tracer, readPostMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/PostStorageServicer", Method: "ReadPost", Remote: false}), readPostsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/PostStorageServicer", Method: "ReadPosts", Remote: false}), removePostMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/PostStorageServicer", Method: "RemovePost", Remote: false}), storePostMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/PostStorageServicer", Method: "StorePost", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return postStorageServicer_client_stub{stub: stub, readPostMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/PostStorageServicer", Method: "ReadPost", Remote: true}), readPostsMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/PostStorageServicer", Method: "ReadPosts", Remote: true}), removePostMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/PostStorageServicer", Method: "RemovePost", Remote: true}), storePostMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/PostStorageServicer", Method: "StorePost", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return postStorageServicer_server_stub{impl: impl.(PostStorageServicer), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return postStorageServicer_reflect_stub{caller: caller}
		},
		RefData: "⟦c068965c:wEaVeReDgE:SocialNetwork/server/PostStorageServicer→SocialNetwork/server/IStorage⟧\n",
	})
	codegen.Register(codegen.Registration{
		Name:  "SocialNetwork/server/UserServicer",
		Iface: reflect.TypeOf((*UserServicer)(nil)).Elem(),
		Impl:  reflect.TypeOf(UserService{}),
		LocalStubFn: func(impl any, caller string, tracer trace.Tracer) any {
			return userServicer_local_stub{impl: impl.(UserServicer), tracer: tracer, composeCreatorWithUserIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/UserServicer", Method: "ComposeCreatorWithUserId", Remote: false}), composeCreatorWithUsernameMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/UserServicer", Method: "ComposeCreatorWithUsername", Remote: false}), getUserIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/UserServicer", Method: "GetUserId", Remote: false}), loginMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/UserServicer", Method: "Login", Remote: false}), registerUserMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/UserServicer", Method: "RegisterUser", Remote: false}), registerUserWithIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/UserServicer", Method: "RegisterUserWithId", Remote: false})}
		},
		ClientStubFn: func(stub codegen.Stub, caller string) any {
			return userServicer_client_stub{stub: stub, composeCreatorWithUserIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/UserServicer", Method: "ComposeCreatorWithUserId", Remote: true}), composeCreatorWithUsernameMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/UserServicer", Method: "ComposeCreatorWithUsername", Remote: true}), getUserIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/UserServicer", Method: "GetUserId", Remote: true}), loginMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/UserServicer", Method: "Login", Remote: true}), registerUserMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/UserServicer", Method: "RegisterUser", Remote: true}), registerUserWithIdMetrics: codegen.MethodMetricsFor(codegen.MethodLabels{Caller: caller, Component: "SocialNetwork/server/UserServicer", Method: "RegisterUserWithId", Remote: true})}
		},
		ServerStubFn: func(impl any, addLoad func(uint64, float64)) codegen.Server {
			return userServicer_server_stub{impl: impl.(UserServicer), addLoad: addLoad}
		},
		ReflectStubFn: func(caller func(string, context.Context, []any, []any) error) any {
			return userServicer_reflect_stub{caller: caller}
		},
		RefData: "⟦a9b4c4bc:wEaVeReDgE:SocialNetwork/server/UserServicer→SocialNetwork/server/IStorage⟧\n",
	})
}

// weaver.InstanceOf checks.
var _ weaver.InstanceOf[BackendServicer] = (*BackendService)(nil)
var _ weaver.InstanceOf[IHomeTimelineService] = (*HomeTimelineService)(nil)
var _ weaver.InstanceOf[IMediaService] = (*MediaService)(nil)
var _ weaver.InstanceOf[ISocialGraphService] = (*SocialGraphService)(nil)
var _ weaver.InstanceOf[IStorage] = (*Storage)(nil)
var _ weaver.InstanceOf[ITextService] = (*TextService)(nil)
var _ weaver.InstanceOf[IUniqueIdService] = (*UniqueIdService)(nil)
var _ weaver.InstanceOf[IUrlShortenService] = (*UrlShortenService)(nil)
var _ weaver.InstanceOf[IUserMentionService] = (*UserMentionService)(nil)
var _ weaver.InstanceOf[IUserTimelineService] = (*UserTimelineService)(nil)
var _ weaver.InstanceOf[weaver.Main] = (*app)(nil)
var _ weaver.InstanceOf[MediaStorageServicer] = (*MediaStorageService)(nil)
var _ weaver.InstanceOf[PostStorageServicer] = (*PostStorageService)(nil)
var _ weaver.InstanceOf[UserServicer] = (*UserService)(nil)

// weaver.Router checks.
var _ weaver.Unrouted = (*BackendService)(nil)
var _ weaver.Unrouted = (*HomeTimelineService)(nil)
var _ weaver.Unrouted = (*MediaService)(nil)
var _ weaver.Unrouted = (*SocialGraphService)(nil)
var _ weaver.RoutedBy[StorageRouter] = (*Storage)(nil)
var _ weaver.Unrouted = (*TextService)(nil)
var _ weaver.Unrouted = (*UniqueIdService)(nil)
var _ weaver.Unrouted = (*UrlShortenService)(nil)
var _ weaver.Unrouted = (*UserMentionService)(nil)
var _ weaver.Unrouted = (*UserTimelineService)(nil)
var _ weaver.Unrouted = (*app)(nil)
var _ weaver.Unrouted = (*MediaStorageService)(nil)
var _ weaver.Unrouted = (*PostStorageService)(nil)
var _ weaver.Unrouted = (*UserService)(nil)

// Component "Storage", router "StorageRouter" checks.
var _ func(context.Context, string, UserProfile) string = (&StorageRouter{}).PutUserProfile     // routed
var _ func(context.Context, string) string = (&StorageRouter{}).GetUserProfile                  // routed
var _ func(context.Context, int64, Post) string = (&StorageRouter{}).PutPost                    // routed
var _ func(context.Context, int64) string = (&StorageRouter{}).GetPost                          // routed
var _ func(context.Context, int64) string = (&StorageRouter{}).RemovePost                       // routed
var _ func(context.Context, string, string) string = (&StorageRouter{}).PutMediaData            // routed
var _ func(context.Context, string) string = (&StorageRouter{}).GetMediaData                    // routed
var _ func(context.Context, string, string) string = (&StorageRouter{}).PutShortenUrl           // routed
var _ func(context.Context, string) string = (&StorageRouter{}).GetShortenUrl                   // routed
var _ func(context.Context, string) string = (&StorageRouter{}).RemoveShortenUrl                // routed
var _ func(context.Context, int64, int64) string = (&StorageRouter{}).Follow                    // routed
var _ func(context.Context, int64, int64) string = (&StorageRouter{}).Unfollow                  // routed
var _ func(context.Context, int64) string = (&StorageRouter{}).GetFollowers                     // routed
var _ func(context.Context, int64) string = (&StorageRouter{}).GetFollowees                     // routed
var _ func(context.Context, int64, int64, int64) string = (&StorageRouter{}).PutPostTimeline    // routed
var _ func(context.Context, int64, int, int) string = (&StorageRouter{}).GetPostTimeline        // routed
var _ func(context.Context, int64, int64, int64) string = (&StorageRouter{}).RemovePostTimeline // routed

// Local stub implementations.

type backendServicer_local_stub struct {
	impl                        BackendServicer
	tracer                      trace.Tracer
	compostPostMetrics          *codegen.MethodMetrics
	followMetrics               *codegen.MethodMetrics
	followWithUsernameMetrics   *codegen.MethodMetrics
	getFolloweesMetrics         *codegen.MethodMetrics
	getFollowersMetrics         *codegen.MethodMetrics
	getMediaMetrics             *codegen.MethodMetrics
	loginMetrics                *codegen.MethodMetrics
	readHomeTimelineMetrics     *codegen.MethodMetrics
	readUserTimelineMetrics     *codegen.MethodMetrics
	registerUserMetrics         *codegen.MethodMetrics
	registerUserWithIdMetrics   *codegen.MethodMetrics
	removePostsMetrics          *codegen.MethodMetrics
	unfollowMetrics             *codegen.MethodMetrics
	unfollowWithUsernameMetrics *codegen.MethodMetrics
	uploadMediaMetrics          *codegen.MethodMetrics
}

// Check that backendServicer_local_stub implements the BackendServicer interface.
var _ BackendServicer = (*backendServicer_local_stub)(nil)

func (s backendServicer_local_stub) CompostPost(ctx context.Context, a0 string, a1 int64, a2 string, a3 []int64, a4 []string, a5 PostType) (err error) {
	// Update metrics.
	begin := s.compostPostMetrics.Begin()
	defer func() { s.compostPostMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.BackendServicer.CompostPost", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.CompostPost(ctx, a0, a1, a2, a3, a4, a5)
}

func (s backendServicer_local_stub) Follow(ctx context.Context, a0 int64, a1 int64) (err error) {
	// Update metrics.
	begin := s.followMetrics.Begin()
	defer func() { s.followMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.BackendServicer.Follow", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.Follow(ctx, a0, a1)
}

func (s backendServicer_local_stub) FollowWithUsername(ctx context.Context, a0 string, a1 string) (err error) {
	// Update metrics.
	begin := s.followWithUsernameMetrics.Begin()
	defer func() { s.followWithUsernameMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.BackendServicer.FollowWithUsername", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.FollowWithUsername(ctx, a0, a1)
}

func (s backendServicer_local_stub) GetFollowees(ctx context.Context, a0 int64) (r0 []int64, err error) {
	// Update metrics.
	begin := s.getFolloweesMetrics.Begin()
	defer func() { s.getFolloweesMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.BackendServicer.GetFollowees", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetFollowees(ctx, a0)
}

func (s backendServicer_local_stub) GetFollowers(ctx context.Context, a0 int64) (r0 []int64, err error) {
	// Update metrics.
	begin := s.getFollowersMetrics.Begin()
	defer func() { s.getFollowersMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.BackendServicer.GetFollowers", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetFollowers(ctx, a0)
}

func (s backendServicer_local_stub) GetMedia(ctx context.Context, a0 string) (r0 string, err error) {
	// Update metrics.
	begin := s.getMediaMetrics.Begin()
	defer func() { s.getMediaMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.BackendServicer.GetMedia", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetMedia(ctx, a0)
}

func (s backendServicer_local_stub) Login(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	// Update metrics.
	begin := s.loginMetrics.Begin()
	defer func() { s.loginMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.BackendServicer.Login", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.Login(ctx, a0, a1)
}

func (s backendServicer_local_stub) ReadHomeTimeline(ctx context.Context, a0 int64, a1 int, a2 int) (r0 []Post, err error) {
	// Update metrics.
	begin := s.readHomeTimelineMetrics.Begin()
	defer func() { s.readHomeTimelineMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.BackendServicer.ReadHomeTimeline", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ReadHomeTimeline(ctx, a0, a1, a2)
}

func (s backendServicer_local_stub) ReadUserTimeline(ctx context.Context, a0 int64, a1 int, a2 int) (r0 []Post, err error) {
	// Update metrics.
	begin := s.readUserTimelineMetrics.Begin()
	defer func() { s.readUserTimelineMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.BackendServicer.ReadUserTimeline", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ReadUserTimeline(ctx, a0, a1, a2)
}

func (s backendServicer_local_stub) RegisterUser(ctx context.Context, a0 string, a1 string, a2 string, a3 string) (err error) {
	// Update metrics.
	begin := s.registerUserMetrics.Begin()
	defer func() { s.registerUserMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.BackendServicer.RegisterUser", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.RegisterUser(ctx, a0, a1, a2, a3)
}

func (s backendServicer_local_stub) RegisterUserWithId(ctx context.Context, a0 string, a1 string, a2 string, a3 string, a4 int64) (err error) {
	// Update metrics.
	begin := s.registerUserWithIdMetrics.Begin()
	defer func() { s.registerUserWithIdMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.BackendServicer.RegisterUserWithId", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.RegisterUserWithId(ctx, a0, a1, a2, a3, a4)
}

func (s backendServicer_local_stub) RemovePosts(ctx context.Context, a0 int64, a1 int, a2 int) (err error) {
	// Update metrics.
	begin := s.removePostsMetrics.Begin()
	defer func() { s.removePostsMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.BackendServicer.RemovePosts", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.RemovePosts(ctx, a0, a1, a2)
}

func (s backendServicer_local_stub) Unfollow(ctx context.Context, a0 int64, a1 int64) (err error) {
	// Update metrics.
	begin := s.unfollowMetrics.Begin()
	defer func() { s.unfollowMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.BackendServicer.Unfollow", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.Unfollow(ctx, a0, a1)
}

func (s backendServicer_local_stub) UnfollowWithUsername(ctx context.Context, a0 string, a1 string) (err error) {
	// Update metrics.
	begin := s.unfollowWithUsernameMetrics.Begin()
	defer func() { s.unfollowWithUsernameMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.BackendServicer.UnfollowWithUsername", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.UnfollowWithUsername(ctx, a0, a1)
}

func (s backendServicer_local_stub) UploadMedia(ctx context.Context, a0 string, a1 string) (err error) {
	// Update metrics.
	begin := s.uploadMediaMetrics.Begin()
	defer func() { s.uploadMediaMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.BackendServicer.UploadMedia", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.UploadMedia(ctx, a0, a1)
}

type iHomeTimelineService_local_stub struct {
	impl                     IHomeTimelineService
	tracer                   trace.Tracer
	readHomeTimelineMetrics  *codegen.MethodMetrics
	removePostMetrics        *codegen.MethodMetrics
	writeHomeTimelineMetrics *codegen.MethodMetrics
}

// Check that iHomeTimelineService_local_stub implements the IHomeTimelineService interface.
var _ IHomeTimelineService = (*iHomeTimelineService_local_stub)(nil)

func (s iHomeTimelineService_local_stub) ReadHomeTimeline(ctx context.Context, a0 int64, a1 int, a2 int) (r0 []Post, err error) {
	// Update metrics.
	begin := s.readHomeTimelineMetrics.Begin()
	defer func() { s.readHomeTimelineMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IHomeTimelineService.ReadHomeTimeline", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ReadHomeTimeline(ctx, a0, a1, a2)
}

func (s iHomeTimelineService_local_stub) RemovePost(ctx context.Context, a0 int64, a1 int64, a2 int64) (err error) {
	// Update metrics.
	begin := s.removePostMetrics.Begin()
	defer func() { s.removePostMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IHomeTimelineService.RemovePost", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.RemovePost(ctx, a0, a1, a2)
}

func (s iHomeTimelineService_local_stub) WriteHomeTimeline(ctx context.Context, a0 int64, a1 int64, a2 int64, a3 []int64) (err error) {
	// Update metrics.
	begin := s.writeHomeTimelineMetrics.Begin()
	defer func() { s.writeHomeTimelineMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IHomeTimelineService.WriteHomeTimeline", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.WriteHomeTimeline(ctx, a0, a1, a2, a3)
}

type iMediaService_local_stub struct {
	impl                IMediaService
	tracer              trace.Tracer
	composeMediaMetrics *codegen.MethodMetrics
}

// Check that iMediaService_local_stub implements the IMediaService interface.
var _ IMediaService = (*iMediaService_local_stub)(nil)

func (s iMediaService_local_stub) ComposeMedia(ctx context.Context, a0 []string, a1 []int64) (r0 []Media, err error) {
	// Update metrics.
	begin := s.composeMediaMetrics.Begin()
	defer func() { s.composeMediaMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IMediaService.ComposeMedia", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ComposeMedia(ctx, a0, a1)
}

type iSocialGraphService_local_stub struct {
	impl                        ISocialGraphService
	tracer                      trace.Tracer
	followMetrics               *codegen.MethodMetrics
	followWithUsernameMetrics   *codegen.MethodMetrics
	getFolloweesMetrics         *codegen.MethodMetrics
	getFollowersMetrics         *codegen.MethodMetrics
	unfollowMetrics             *codegen.MethodMetrics
	unfollowWithUsernameMetrics *codegen.MethodMetrics
}

// Check that iSocialGraphService_local_stub implements the ISocialGraphService interface.
var _ ISocialGraphService = (*iSocialGraphService_local_stub)(nil)

func (s iSocialGraphService_local_stub) Follow(ctx context.Context, a0 int64, a1 int64) (err error) {
	// Update metrics.
	begin := s.followMetrics.Begin()
	defer func() { s.followMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.ISocialGraphService.Follow", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.Follow(ctx, a0, a1)
}

func (s iSocialGraphService_local_stub) FollowWithUsername(ctx context.Context, a0 string, a1 string) (err error) {
	// Update metrics.
	begin := s.followWithUsernameMetrics.Begin()
	defer func() { s.followWithUsernameMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.ISocialGraphService.FollowWithUsername", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.FollowWithUsername(ctx, a0, a1)
}

func (s iSocialGraphService_local_stub) GetFollowees(ctx context.Context, a0 int64) (r0 []int64, err error) {
	// Update metrics.
	begin := s.getFolloweesMetrics.Begin()
	defer func() { s.getFolloweesMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.ISocialGraphService.GetFollowees", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetFollowees(ctx, a0)
}

func (s iSocialGraphService_local_stub) GetFollowers(ctx context.Context, a0 int64) (r0 []int64, err error) {
	// Update metrics.
	begin := s.getFollowersMetrics.Begin()
	defer func() { s.getFollowersMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.ISocialGraphService.GetFollowers", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetFollowers(ctx, a0)
}

func (s iSocialGraphService_local_stub) Unfollow(ctx context.Context, a0 int64, a1 int64) (err error) {
	// Update metrics.
	begin := s.unfollowMetrics.Begin()
	defer func() { s.unfollowMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.ISocialGraphService.Unfollow", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.Unfollow(ctx, a0, a1)
}

func (s iSocialGraphService_local_stub) UnfollowWithUsername(ctx context.Context, a0 string, a1 string) (err error) {
	// Update metrics.
	begin := s.unfollowWithUsernameMetrics.Begin()
	defer func() { s.unfollowWithUsernameMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.ISocialGraphService.UnfollowWithUsername", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.UnfollowWithUsername(ctx, a0, a1)
}

type iStorage_local_stub struct {
	impl                      IStorage
	tracer                    trace.Tracer
	followMetrics             *codegen.MethodMetrics
	getFolloweesMetrics       *codegen.MethodMetrics
	getFollowersMetrics       *codegen.MethodMetrics
	getMediaDataMetrics       *codegen.MethodMetrics
	getPostMetrics            *codegen.MethodMetrics
	getPostTimelineMetrics    *codegen.MethodMetrics
	getShortenUrlMetrics      *codegen.MethodMetrics
	getUserProfileMetrics     *codegen.MethodMetrics
	putMediaDataMetrics       *codegen.MethodMetrics
	putPostMetrics            *codegen.MethodMetrics
	putPostTimelineMetrics    *codegen.MethodMetrics
	putShortenUrlMetrics      *codegen.MethodMetrics
	putUserProfileMetrics     *codegen.MethodMetrics
	removePostMetrics         *codegen.MethodMetrics
	removePostTimelineMetrics *codegen.MethodMetrics
	removeShortenUrlMetrics   *codegen.MethodMetrics
	unfollowMetrics           *codegen.MethodMetrics
}

// Check that iStorage_local_stub implements the IStorage interface.
var _ IStorage = (*iStorage_local_stub)(nil)

func (s iStorage_local_stub) Follow(ctx context.Context, a0 int64, a1 int64) (err error) {
	// Update metrics.
	begin := s.followMetrics.Begin()
	defer func() { s.followMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IStorage.Follow", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.Follow(ctx, a0, a1)
}

func (s iStorage_local_stub) GetFollowees(ctx context.Context, a0 int64) (r0 map[int64]bool, r1 bool, err error) {
	// Update metrics.
	begin := s.getFolloweesMetrics.Begin()
	defer func() { s.getFolloweesMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IStorage.GetFollowees", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetFollowees(ctx, a0)
}

func (s iStorage_local_stub) GetFollowers(ctx context.Context, a0 int64) (r0 map[int64]bool, r1 bool, err error) {
	// Update metrics.
	begin := s.getFollowersMetrics.Begin()
	defer func() { s.getFollowersMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IStorage.GetFollowers", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetFollowers(ctx, a0)
}

func (s iStorage_local_stub) GetMediaData(ctx context.Context, a0 string) (r0 string, r1 bool, err error) {
	// Update metrics.
	begin := s.getMediaDataMetrics.Begin()
	defer func() { s.getMediaDataMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IStorage.GetMediaData", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetMediaData(ctx, a0)
}

func (s iStorage_local_stub) GetPost(ctx context.Context, a0 int64) (r0 Post, r1 bool, err error) {
	// Update metrics.
	begin := s.getPostMetrics.Begin()
	defer func() { s.getPostMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IStorage.GetPost", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetPost(ctx, a0)
}

func (s iStorage_local_stub) GetPostTimeline(ctx context.Context, a0 int64, a1 int, a2 int) (r0 []int64, err error) {
	// Update metrics.
	begin := s.getPostTimelineMetrics.Begin()
	defer func() { s.getPostTimelineMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IStorage.GetPostTimeline", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetPostTimeline(ctx, a0, a1, a2)
}

func (s iStorage_local_stub) GetShortenUrl(ctx context.Context, a0 string) (r0 string, r1 bool, err error) {
	// Update metrics.
	begin := s.getShortenUrlMetrics.Begin()
	defer func() { s.getShortenUrlMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IStorage.GetShortenUrl", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetShortenUrl(ctx, a0)
}

func (s iStorage_local_stub) GetUserProfile(ctx context.Context, a0 string) (r0 UserProfile, r1 bool, err error) {
	// Update metrics.
	begin := s.getUserProfileMetrics.Begin()
	defer func() { s.getUserProfileMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IStorage.GetUserProfile", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetUserProfile(ctx, a0)
}

func (s iStorage_local_stub) PutMediaData(ctx context.Context, a0 string, a1 string) (err error) {
	// Update metrics.
	begin := s.putMediaDataMetrics.Begin()
	defer func() { s.putMediaDataMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IStorage.PutMediaData", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PutMediaData(ctx, a0, a1)
}

func (s iStorage_local_stub) PutPost(ctx context.Context, a0 int64, a1 Post) (err error) {
	// Update metrics.
	begin := s.putPostMetrics.Begin()
	defer func() { s.putPostMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IStorage.PutPost", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PutPost(ctx, a0, a1)
}

func (s iStorage_local_stub) PutPostTimeline(ctx context.Context, a0 int64, a1 int64, a2 int64) (err error) {
	// Update metrics.
	begin := s.putPostTimelineMetrics.Begin()
	defer func() { s.putPostTimelineMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IStorage.PutPostTimeline", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PutPostTimeline(ctx, a0, a1, a2)
}

func (s iStorage_local_stub) PutShortenUrl(ctx context.Context, a0 string, a1 string) (err error) {
	// Update metrics.
	begin := s.putShortenUrlMetrics.Begin()
	defer func() { s.putShortenUrlMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IStorage.PutShortenUrl", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PutShortenUrl(ctx, a0, a1)
}

func (s iStorage_local_stub) PutUserProfile(ctx context.Context, a0 string, a1 UserProfile) (err error) {
	// Update metrics.
	begin := s.putUserProfileMetrics.Begin()
	defer func() { s.putUserProfileMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IStorage.PutUserProfile", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.PutUserProfile(ctx, a0, a1)
}

func (s iStorage_local_stub) RemovePost(ctx context.Context, a0 int64) (r0 bool, err error) {
	// Update metrics.
	begin := s.removePostMetrics.Begin()
	defer func() { s.removePostMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IStorage.RemovePost", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.RemovePost(ctx, a0)
}

func (s iStorage_local_stub) RemovePostTimeline(ctx context.Context, a0 int64, a1 int64, a2 int64) (err error) {
	// Update metrics.
	begin := s.removePostTimelineMetrics.Begin()
	defer func() { s.removePostTimelineMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IStorage.RemovePostTimeline", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.RemovePostTimeline(ctx, a0, a1, a2)
}

func (s iStorage_local_stub) RemoveShortenUrl(ctx context.Context, a0 string) (err error) {
	// Update metrics.
	begin := s.removeShortenUrlMetrics.Begin()
	defer func() { s.removeShortenUrlMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IStorage.RemoveShortenUrl", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.RemoveShortenUrl(ctx, a0)
}

func (s iStorage_local_stub) Unfollow(ctx context.Context, a0 int64, a1 int64) (err error) {
	// Update metrics.
	begin := s.unfollowMetrics.Begin()
	defer func() { s.unfollowMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IStorage.Unfollow", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.Unfollow(ctx, a0, a1)
}

type iTextService_local_stub struct {
	impl               ITextService
	tracer             trace.Tracer
	composeTextMetrics *codegen.MethodMetrics
}

// Check that iTextService_local_stub implements the ITextService interface.
var _ ITextService = (*iTextService_local_stub)(nil)

func (s iTextService_local_stub) ComposeText(ctx context.Context, a0 string) (r0 TextServiceReturn, err error) {
	// Update metrics.
	begin := s.composeTextMetrics.Begin()
	defer func() { s.composeTextMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.ITextService.ComposeText", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ComposeText(ctx, a0)
}

type iUniqueIdService_local_stub struct {
	impl                   IUniqueIdService
	tracer                 trace.Tracer
	composeUniqueIdMetrics *codegen.MethodMetrics
}

// Check that iUniqueIdService_local_stub implements the IUniqueIdService interface.
var _ IUniqueIdService = (*iUniqueIdService_local_stub)(nil)

func (s iUniqueIdService_local_stub) ComposeUniqueId(ctx context.Context, a0 PostType) (r0 int64, err error) {
	// Update metrics.
	begin := s.composeUniqueIdMetrics.Begin()
	defer func() { s.composeUniqueIdMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IUniqueIdService.ComposeUniqueId", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ComposeUniqueId(ctx, a0)
}

type iUrlShortenService_local_stub struct {
	impl                   IUrlShortenService
	tracer                 trace.Tracer
	composeUrlMetrics      *codegen.MethodMetrics
	getExtendedUrlsMetrics *codegen.MethodMetrics
	removeUrlsMetrics      *codegen.MethodMetrics
}

// Check that iUrlShortenService_local_stub implements the IUrlShortenService interface.
var _ IUrlShortenService = (*iUrlShortenService_local_stub)(nil)

func (s iUrlShortenService_local_stub) ComposeUrl(ctx context.Context, a0 []string) (r0 []Url, err error) {
	// Update metrics.
	begin := s.composeUrlMetrics.Begin()
	defer func() { s.composeUrlMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IUrlShortenService.ComposeUrl", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ComposeUrl(ctx, a0)
}

func (s iUrlShortenService_local_stub) GetExtendedUrls(ctx context.Context, a0 []string) (r0 []string, err error) {
	// Update metrics.
	begin := s.getExtendedUrlsMetrics.Begin()
	defer func() { s.getExtendedUrlsMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IUrlShortenService.GetExtendedUrls", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetExtendedUrls(ctx, a0)
}

func (s iUrlShortenService_local_stub) RemoveUrls(ctx context.Context, a0 []string) (err error) {
	// Update metrics.
	begin := s.removeUrlsMetrics.Begin()
	defer func() { s.removeUrlsMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IUrlShortenService.RemoveUrls", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.RemoveUrls(ctx, a0)
}

type iUserMentionService_local_stub struct {
	impl                       IUserMentionService
	tracer                     trace.Tracer
	composeUserMentionsMetrics *codegen.MethodMetrics
}

// Check that iUserMentionService_local_stub implements the IUserMentionService interface.
var _ IUserMentionService = (*iUserMentionService_local_stub)(nil)

func (s iUserMentionService_local_stub) ComposeUserMentions(ctx context.Context, a0 []string) (r0 []UserMention, err error) {
	// Update metrics.
	begin := s.composeUserMentionsMetrics.Begin()
	defer func() { s.composeUserMentionsMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IUserMentionService.ComposeUserMentions", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ComposeUserMentions(ctx, a0)
}

type iUserTimelineService_local_stub struct {
	impl                     IUserTimelineService
	tracer                   trace.Tracer
	readUserTimelineMetrics  *codegen.MethodMetrics
	removePostMetrics        *codegen.MethodMetrics
	writeUserTimelineMetrics *codegen.MethodMetrics
}

// Check that iUserTimelineService_local_stub implements the IUserTimelineService interface.
var _ IUserTimelineService = (*iUserTimelineService_local_stub)(nil)

func (s iUserTimelineService_local_stub) ReadUserTimeline(ctx context.Context, a0 int64, a1 int, a2 int) (r0 []Post, err error) {
	// Update metrics.
	begin := s.readUserTimelineMetrics.Begin()
	defer func() { s.readUserTimelineMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IUserTimelineService.ReadUserTimeline", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ReadUserTimeline(ctx, a0, a1, a2)
}

func (s iUserTimelineService_local_stub) RemovePost(ctx context.Context, a0 int64, a1 int64, a2 int64) (err error) {
	// Update metrics.
	begin := s.removePostMetrics.Begin()
	defer func() { s.removePostMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IUserTimelineService.RemovePost", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.RemovePost(ctx, a0, a1, a2)
}

func (s iUserTimelineService_local_stub) WriteUserTimeline(ctx context.Context, a0 int64, a1 int64, a2 int64) (err error) {
	// Update metrics.
	begin := s.writeUserTimelineMetrics.Begin()
	defer func() { s.writeUserTimelineMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.IUserTimelineService.WriteUserTimeline", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.WriteUserTimeline(ctx, a0, a1, a2)
}

type main_local_stub struct {
	impl   weaver.Main
	tracer trace.Tracer
}

// Check that main_local_stub implements the weaver.Main interface.
var _ weaver.Main = (*main_local_stub)(nil)

type mediaStorageServicer_local_stub struct {
	impl               MediaStorageServicer
	tracer             trace.Tracer
	getMediaMetrics    *codegen.MethodMetrics
	uploadMediaMetrics *codegen.MethodMetrics
}

// Check that mediaStorageServicer_local_stub implements the MediaStorageServicer interface.
var _ MediaStorageServicer = (*mediaStorageServicer_local_stub)(nil)

func (s mediaStorageServicer_local_stub) GetMedia(ctx context.Context, a0 string) (r0 string, err error) {
	// Update metrics.
	begin := s.getMediaMetrics.Begin()
	defer func() { s.getMediaMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.MediaStorageServicer.GetMedia", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetMedia(ctx, a0)
}

func (s mediaStorageServicer_local_stub) UploadMedia(ctx context.Context, a0 string, a1 string) (err error) {
	// Update metrics.
	begin := s.uploadMediaMetrics.Begin()
	defer func() { s.uploadMediaMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.MediaStorageServicer.UploadMedia", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.UploadMedia(ctx, a0, a1)
}

type postStorageServicer_local_stub struct {
	impl              PostStorageServicer
	tracer            trace.Tracer
	readPostMetrics   *codegen.MethodMetrics
	readPostsMetrics  *codegen.MethodMetrics
	removePostMetrics *codegen.MethodMetrics
	storePostMetrics  *codegen.MethodMetrics
}

// Check that postStorageServicer_local_stub implements the PostStorageServicer interface.
var _ PostStorageServicer = (*postStorageServicer_local_stub)(nil)

func (s postStorageServicer_local_stub) ReadPost(ctx context.Context, a0 int64) (r0 Post, err error) {
	// Update metrics.
	begin := s.readPostMetrics.Begin()
	defer func() { s.readPostMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.PostStorageServicer.ReadPost", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ReadPost(ctx, a0)
}

func (s postStorageServicer_local_stub) ReadPosts(ctx context.Context, a0 []int64) (r0 []Post, err error) {
	// Update metrics.
	begin := s.readPostsMetrics.Begin()
	defer func() { s.readPostsMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.PostStorageServicer.ReadPosts", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ReadPosts(ctx, a0)
}

func (s postStorageServicer_local_stub) RemovePost(ctx context.Context, a0 int64) (r0 bool, err error) {
	// Update metrics.
	begin := s.removePostMetrics.Begin()
	defer func() { s.removePostMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.PostStorageServicer.RemovePost", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.RemovePost(ctx, a0)
}

func (s postStorageServicer_local_stub) StorePost(ctx context.Context, a0 Post) (err error) {
	// Update metrics.
	begin := s.storePostMetrics.Begin()
	defer func() { s.storePostMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.PostStorageServicer.StorePost", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.StorePost(ctx, a0)
}

type userServicer_local_stub struct {
	impl                              UserServicer
	tracer                            trace.Tracer
	composeCreatorWithUserIdMetrics   *codegen.MethodMetrics
	composeCreatorWithUsernameMetrics *codegen.MethodMetrics
	getUserIdMetrics                  *codegen.MethodMetrics
	loginMetrics                      *codegen.MethodMetrics
	registerUserMetrics               *codegen.MethodMetrics
	registerUserWithIdMetrics         *codegen.MethodMetrics
}

// Check that userServicer_local_stub implements the UserServicer interface.
var _ UserServicer = (*userServicer_local_stub)(nil)

func (s userServicer_local_stub) ComposeCreatorWithUserId(ctx context.Context, a0 int64, a1 string) (r0 Creator, err error) {
	// Update metrics.
	begin := s.composeCreatorWithUserIdMetrics.Begin()
	defer func() { s.composeCreatorWithUserIdMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.UserServicer.ComposeCreatorWithUserId", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ComposeCreatorWithUserId(ctx, a0, a1)
}

func (s userServicer_local_stub) ComposeCreatorWithUsername(ctx context.Context, a0 string) (r0 Creator, err error) {
	// Update metrics.
	begin := s.composeCreatorWithUsernameMetrics.Begin()
	defer func() { s.composeCreatorWithUsernameMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.UserServicer.ComposeCreatorWithUsername", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.ComposeCreatorWithUsername(ctx, a0)
}

func (s userServicer_local_stub) GetUserId(ctx context.Context, a0 string) (r0 int64, err error) {
	// Update metrics.
	begin := s.getUserIdMetrics.Begin()
	defer func() { s.getUserIdMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.UserServicer.GetUserId", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.GetUserId(ctx, a0)
}

func (s userServicer_local_stub) Login(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	// Update metrics.
	begin := s.loginMetrics.Begin()
	defer func() { s.loginMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.UserServicer.Login", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.Login(ctx, a0, a1)
}

func (s userServicer_local_stub) RegisterUser(ctx context.Context, a0 string, a1 string, a2 string, a3 string) (err error) {
	// Update metrics.
	begin := s.registerUserMetrics.Begin()
	defer func() { s.registerUserMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.UserServicer.RegisterUser", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.RegisterUser(ctx, a0, a1, a2, a3)
}

func (s userServicer_local_stub) RegisterUserWithId(ctx context.Context, a0 string, a1 string, a2 string, a3 string, a4 int64) (err error) {
	// Update metrics.
	begin := s.registerUserWithIdMetrics.Begin()
	defer func() { s.registerUserWithIdMetrics.End(begin, err != nil, 0, 0) }()
	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.tracer.Start(ctx, "main.UserServicer.RegisterUserWithId", trace.WithSpanKind(trace.SpanKindInternal))
		defer func() {
			if err != nil {
				span.RecordError(err)
				span.SetStatus(codes.Error, err.Error())
			}
			span.End()
		}()
	}

	return s.impl.RegisterUserWithId(ctx, a0, a1, a2, a3, a4)
}

// Client stub implementations.

type backendServicer_client_stub struct {
	stub                        codegen.Stub
	compostPostMetrics          *codegen.MethodMetrics
	followMetrics               *codegen.MethodMetrics
	followWithUsernameMetrics   *codegen.MethodMetrics
	getFolloweesMetrics         *codegen.MethodMetrics
	getFollowersMetrics         *codegen.MethodMetrics
	getMediaMetrics             *codegen.MethodMetrics
	loginMetrics                *codegen.MethodMetrics
	readHomeTimelineMetrics     *codegen.MethodMetrics
	readUserTimelineMetrics     *codegen.MethodMetrics
	registerUserMetrics         *codegen.MethodMetrics
	registerUserWithIdMetrics   *codegen.MethodMetrics
	removePostsMetrics          *codegen.MethodMetrics
	unfollowMetrics             *codegen.MethodMetrics
	unfollowWithUsernameMetrics *codegen.MethodMetrics
	uploadMediaMetrics          *codegen.MethodMetrics
}

// Check that backendServicer_client_stub implements the BackendServicer interface.
var _ BackendServicer = (*backendServicer_client_stub)(nil)

func (s backendServicer_client_stub) CompostPost(ctx context.Context, a0 string, a1 int64, a2 string, a3 []int64, a4 []string, a5 PostType) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.compostPostMetrics.Begin()
	defer func() { s.compostPostMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.BackendServicer.CompostPost", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	enc.String(a0)
	enc.Int64(a1)
	enc.String(a2)
	serviceweaver_enc_slice_int64_a8f7f092(enc, a3)
	serviceweaver_enc_slice_string_4af10117(enc, a4)
	enc.Int((int)(a5))
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s backendServicer_client_stub) Follow(ctx context.Context, a0 int64, a1 int64) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.followMetrics.Begin()
	defer func() { s.followMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.BackendServicer.Follow", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.Int64(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s backendServicer_client_stub) FollowWithUsername(ctx context.Context, a0 string, a1 string) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.followWithUsernameMetrics.Begin()
	defer func() { s.followWithUsernameMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.BackendServicer.FollowWithUsername", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 2, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s backendServicer_client_stub) GetFollowees(ctx context.Context, a0 int64) (r0 []int64, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getFolloweesMetrics.Begin()
	defer func() { s.getFolloweesMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.BackendServicer.GetFollowees", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 3, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_int64_a8f7f092(dec)
	err = dec.Error()
	return
}

func (s backendServicer_client_stub) GetFollowers(ctx context.Context, a0 int64) (r0 []int64, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getFollowersMetrics.Begin()
	defer func() { s.getFollowersMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.BackendServicer.GetFollowers", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 4, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_int64_a8f7f092(dec)
	err = dec.Error()
	return
}

func (s backendServicer_client_stub) GetMedia(ctx context.Context, a0 string) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getMediaMetrics.Begin()
	defer func() { s.getMediaMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.BackendServicer.GetMedia", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 5, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

func (s backendServicer_client_stub) Login(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.loginMetrics.Begin()
	defer func() { s.loginMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.BackendServicer.Login", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 6, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

func (s backendServicer_client_stub) ReadHomeTimeline(ctx context.Context, a0 int64, a1 int, a2 int) (r0 []Post, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.readHomeTimelineMetrics.Begin()
	defer func() { s.readHomeTimelineMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.BackendServicer.ReadHomeTimeline", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += 8
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.Int(a1)
	enc.Int(a2)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 7, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_Post_92420d4c(dec)
	err = dec.Error()
	return
}

func (s backendServicer_client_stub) ReadUserTimeline(ctx context.Context, a0 int64, a1 int, a2 int) (r0 []Post, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.readUserTimelineMetrics.Begin()
	defer func() { s.readUserTimelineMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.BackendServicer.ReadUserTimeline", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += 8
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.Int(a1)
	enc.Int(a2)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 8, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_Post_92420d4c(dec)
	err = dec.Error()
	return
}

func (s backendServicer_client_stub) RegisterUser(ctx context.Context, a0 string, a1 string, a2 string, a3 string) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.registerUserMetrics.Begin()
	defer func() { s.registerUserMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.BackendServicer.RegisterUser", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	size += (4 + len(a2))
	size += (4 + len(a3))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	enc.String(a2)
	enc.String(a3)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 9, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s backendServicer_client_stub) RegisterUserWithId(ctx context.Context, a0 string, a1 string, a2 string, a3 string, a4 int64) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.registerUserWithIdMetrics.Begin()
	defer func() { s.registerUserWithIdMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.BackendServicer.RegisterUserWithId", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	size += (4 + len(a2))
	size += (4 + len(a3))
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	enc.String(a2)
	enc.String(a3)
	enc.Int64(a4)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 10, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s backendServicer_client_stub) RemovePosts(ctx context.Context, a0 int64, a1 int, a2 int) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.removePostsMetrics.Begin()
	defer func() { s.removePostsMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.BackendServicer.RemovePosts", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += 8
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.Int(a1)
	enc.Int(a2)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 11, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s backendServicer_client_stub) Unfollow(ctx context.Context, a0 int64, a1 int64) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.unfollowMetrics.Begin()
	defer func() { s.unfollowMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.BackendServicer.Unfollow", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.Int64(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 12, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s backendServicer_client_stub) UnfollowWithUsername(ctx context.Context, a0 string, a1 string) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.unfollowWithUsernameMetrics.Begin()
	defer func() { s.unfollowWithUsernameMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.BackendServicer.UnfollowWithUsername", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 13, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s backendServicer_client_stub) UploadMedia(ctx context.Context, a0 string, a1 string) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.uploadMediaMetrics.Begin()
	defer func() { s.uploadMediaMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.BackendServicer.UploadMedia", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 14, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

type iHomeTimelineService_client_stub struct {
	stub                     codegen.Stub
	readHomeTimelineMetrics  *codegen.MethodMetrics
	removePostMetrics        *codegen.MethodMetrics
	writeHomeTimelineMetrics *codegen.MethodMetrics
}

// Check that iHomeTimelineService_client_stub implements the IHomeTimelineService interface.
var _ IHomeTimelineService = (*iHomeTimelineService_client_stub)(nil)

func (s iHomeTimelineService_client_stub) ReadHomeTimeline(ctx context.Context, a0 int64, a1 int, a2 int) (r0 []Post, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.readHomeTimelineMetrics.Begin()
	defer func() { s.readHomeTimelineMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IHomeTimelineService.ReadHomeTimeline", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += 8
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.Int(a1)
	enc.Int(a2)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_Post_92420d4c(dec)
	err = dec.Error()
	return
}

func (s iHomeTimelineService_client_stub) RemovePost(ctx context.Context, a0 int64, a1 int64, a2 int64) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.removePostMetrics.Begin()
	defer func() { s.removePostMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IHomeTimelineService.RemovePost", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += 8
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.Int64(a1)
	enc.Int64(a2)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s iHomeTimelineService_client_stub) WriteHomeTimeline(ctx context.Context, a0 int64, a1 int64, a2 int64, a3 []int64) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.writeHomeTimelineMetrics.Begin()
	defer func() { s.writeHomeTimelineMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IHomeTimelineService.WriteHomeTimeline", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += 8
	size += 8
	size += (4 + (len(a3) * 8))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.Int64(a1)
	enc.Int64(a2)
	serviceweaver_enc_slice_int64_a8f7f092(enc, a3)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 2, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

type iMediaService_client_stub struct {
	stub                codegen.Stub
	composeMediaMetrics *codegen.MethodMetrics
}

// Check that iMediaService_client_stub implements the IMediaService interface.
var _ IMediaService = (*iMediaService_client_stub)(nil)

func (s iMediaService_client_stub) ComposeMedia(ctx context.Context, a0 []string, a1 []int64) (r0 []Media, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.composeMediaMetrics.Begin()
	defer func() { s.composeMediaMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IMediaService.ComposeMedia", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_string_4af10117(enc, a0)
	serviceweaver_enc_slice_int64_a8f7f092(enc, a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_Media_7ba3b576(dec)
	err = dec.Error()
	return
}

type iSocialGraphService_client_stub struct {
	stub                        codegen.Stub
	followMetrics               *codegen.MethodMetrics
	followWithUsernameMetrics   *codegen.MethodMetrics
	getFolloweesMetrics         *codegen.MethodMetrics
	getFollowersMetrics         *codegen.MethodMetrics
	unfollowMetrics             *codegen.MethodMetrics
	unfollowWithUsernameMetrics *codegen.MethodMetrics
}

// Check that iSocialGraphService_client_stub implements the ISocialGraphService interface.
var _ ISocialGraphService = (*iSocialGraphService_client_stub)(nil)

func (s iSocialGraphService_client_stub) Follow(ctx context.Context, a0 int64, a1 int64) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.followMetrics.Begin()
	defer func() { s.followMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.ISocialGraphService.Follow", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.Int64(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s iSocialGraphService_client_stub) FollowWithUsername(ctx context.Context, a0 string, a1 string) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.followWithUsernameMetrics.Begin()
	defer func() { s.followWithUsernameMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.ISocialGraphService.FollowWithUsername", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s iSocialGraphService_client_stub) GetFollowees(ctx context.Context, a0 int64) (r0 []int64, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getFolloweesMetrics.Begin()
	defer func() { s.getFolloweesMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.ISocialGraphService.GetFollowees", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 2, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_int64_a8f7f092(dec)
	err = dec.Error()
	return
}

func (s iSocialGraphService_client_stub) GetFollowers(ctx context.Context, a0 int64) (r0 []int64, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getFollowersMetrics.Begin()
	defer func() { s.getFollowersMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.ISocialGraphService.GetFollowers", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 3, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_int64_a8f7f092(dec)
	err = dec.Error()
	return
}

func (s iSocialGraphService_client_stub) Unfollow(ctx context.Context, a0 int64, a1 int64) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.unfollowMetrics.Begin()
	defer func() { s.unfollowMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.ISocialGraphService.Unfollow", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.Int64(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 4, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s iSocialGraphService_client_stub) UnfollowWithUsername(ctx context.Context, a0 string, a1 string) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.unfollowWithUsernameMetrics.Begin()
	defer func() { s.unfollowWithUsernameMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.ISocialGraphService.UnfollowWithUsername", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 5, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

type iStorage_client_stub struct {
	stub                      codegen.Stub
	followMetrics             *codegen.MethodMetrics
	getFolloweesMetrics       *codegen.MethodMetrics
	getFollowersMetrics       *codegen.MethodMetrics
	getMediaDataMetrics       *codegen.MethodMetrics
	getPostMetrics            *codegen.MethodMetrics
	getPostTimelineMetrics    *codegen.MethodMetrics
	getShortenUrlMetrics      *codegen.MethodMetrics
	getUserProfileMetrics     *codegen.MethodMetrics
	putMediaDataMetrics       *codegen.MethodMetrics
	putPostMetrics            *codegen.MethodMetrics
	putPostTimelineMetrics    *codegen.MethodMetrics
	putShortenUrlMetrics      *codegen.MethodMetrics
	putUserProfileMetrics     *codegen.MethodMetrics
	removePostMetrics         *codegen.MethodMetrics
	removePostTimelineMetrics *codegen.MethodMetrics
	removeShortenUrlMetrics   *codegen.MethodMetrics
	unfollowMetrics           *codegen.MethodMetrics
}

// Check that iStorage_client_stub implements the IStorage interface.
var _ IStorage = (*iStorage_client_stub)(nil)

func (s iStorage_client_stub) Follow(ctx context.Context, a0 int64, a1 int64) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.followMetrics.Begin()
	defer func() { s.followMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IStorage.Follow", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.Int64(a1)

	// Set the shardKey.
	var r StorageRouter
	shardKey := _hashIStorage(r.Follow(ctx, a0, a1))

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s iStorage_client_stub) GetFollowees(ctx context.Context, a0 int64) (r0 map[int64]bool, r1 bool, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getFolloweesMetrics.Begin()
	defer func() { s.getFolloweesMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IStorage.GetFollowees", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)

	// Set the shardKey.
	var r StorageRouter
	shardKey := _hashIStorage(r.GetFollowees(ctx, a0))

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_map_int64_bool_7caa5f14(dec)
	r1 = dec.Bool()
	err = dec.Error()
	return
}

func (s iStorage_client_stub) GetFollowers(ctx context.Context, a0 int64) (r0 map[int64]bool, r1 bool, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getFollowersMetrics.Begin()
	defer func() { s.getFollowersMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IStorage.GetFollowers", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)

	// Set the shardKey.
	var r StorageRouter
	shardKey := _hashIStorage(r.GetFollowers(ctx, a0))

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 2, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_map_int64_bool_7caa5f14(dec)
	r1 = dec.Bool()
	err = dec.Error()
	return
}

func (s iStorage_client_stub) GetMediaData(ctx context.Context, a0 string) (r0 string, r1 bool, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getMediaDataMetrics.Begin()
	defer func() { s.getMediaDataMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IStorage.GetMediaData", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)

	// Set the shardKey.
	var r StorageRouter
	shardKey := _hashIStorage(r.GetMediaData(ctx, a0))

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 3, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	r1 = dec.Bool()
	err = dec.Error()
	return
}

func (s iStorage_client_stub) GetPost(ctx context.Context, a0 int64) (r0 Post, r1 bool, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getPostMetrics.Begin()
	defer func() { s.getPostMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IStorage.GetPost", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)

	// Set the shardKey.
	var r StorageRouter
	shardKey := _hashIStorage(r.GetPost(ctx, a0))

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 4, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	r1 = dec.Bool()
	err = dec.Error()
	return
}

func (s iStorage_client_stub) GetPostTimeline(ctx context.Context, a0 int64, a1 int, a2 int) (r0 []int64, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getPostTimelineMetrics.Begin()
	defer func() { s.getPostTimelineMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IStorage.GetPostTimeline", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += 8
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.Int(a1)
	enc.Int(a2)

	// Set the shardKey.
	var r StorageRouter
	shardKey := _hashIStorage(r.GetPostTimeline(ctx, a0, a1, a2))

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 5, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_int64_a8f7f092(dec)
	err = dec.Error()
	return
}

func (s iStorage_client_stub) GetShortenUrl(ctx context.Context, a0 string) (r0 string, r1 bool, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getShortenUrlMetrics.Begin()
	defer func() { s.getShortenUrlMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IStorage.GetShortenUrl", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)

	// Set the shardKey.
	var r StorageRouter
	shardKey := _hashIStorage(r.GetShortenUrl(ctx, a0))

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 6, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	r1 = dec.Bool()
	err = dec.Error()
	return
}

func (s iStorage_client_stub) GetUserProfile(ctx context.Context, a0 string) (r0 UserProfile, r1 bool, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getUserProfileMetrics.Begin()
	defer func() { s.getUserProfileMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IStorage.GetUserProfile", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)

	// Set the shardKey.
	var r StorageRouter
	shardKey := _hashIStorage(r.GetUserProfile(ctx, a0))

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 7, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	r1 = dec.Bool()
	err = dec.Error()
	return
}

func (s iStorage_client_stub) PutMediaData(ctx context.Context, a0 string, a1 string) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.putMediaDataMetrics.Begin()
	defer func() { s.putMediaDataMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IStorage.PutMediaData", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)

	// Set the shardKey.
	var r StorageRouter
	shardKey := _hashIStorage(r.PutMediaData(ctx, a0, a1))

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 8, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s iStorage_client_stub) PutPost(ctx context.Context, a0 int64, a1 Post) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.putPostMetrics.Begin()
	defer func() { s.putPostMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IStorage.PutPost", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	enc.Int64(a0)
	(a1).WeaverMarshal(enc)

	// Set the shardKey.
	var r StorageRouter
	shardKey := _hashIStorage(r.PutPost(ctx, a0, a1))

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 9, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s iStorage_client_stub) PutPostTimeline(ctx context.Context, a0 int64, a1 int64, a2 int64) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.putPostTimelineMetrics.Begin()
	defer func() { s.putPostTimelineMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IStorage.PutPostTimeline", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += 8
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.Int64(a1)
	enc.Int64(a2)

	// Set the shardKey.
	var r StorageRouter
	shardKey := _hashIStorage(r.PutPostTimeline(ctx, a0, a1, a2))

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 10, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s iStorage_client_stub) PutShortenUrl(ctx context.Context, a0 string, a1 string) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.putShortenUrlMetrics.Begin()
	defer func() { s.putShortenUrlMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IStorage.PutShortenUrl", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)

	// Set the shardKey.
	var r StorageRouter
	shardKey := _hashIStorage(r.PutShortenUrl(ctx, a0, a1))

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 11, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s iStorage_client_stub) PutUserProfile(ctx context.Context, a0 string, a1 UserProfile) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.putUserProfileMetrics.Begin()
	defer func() { s.putUserProfileMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IStorage.PutUserProfile", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += serviceweaver_size_UserProfile_fea8d204(&a1)
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	(a1).WeaverMarshal(enc)

	// Set the shardKey.
	var r StorageRouter
	shardKey := _hashIStorage(r.PutUserProfile(ctx, a0, a1))

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 12, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s iStorage_client_stub) RemovePost(ctx context.Context, a0 int64) (r0 bool, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.removePostMetrics.Begin()
	defer func() { s.removePostMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IStorage.RemovePost", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)

	// Set the shardKey.
	var r StorageRouter
	shardKey := _hashIStorage(r.RemovePost(ctx, a0))

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 13, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.Bool()
	err = dec.Error()
	return
}

func (s iStorage_client_stub) RemovePostTimeline(ctx context.Context, a0 int64, a1 int64, a2 int64) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.removePostTimelineMetrics.Begin()
	defer func() { s.removePostTimelineMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IStorage.RemovePostTimeline", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += 8
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.Int64(a1)
	enc.Int64(a2)

	// Set the shardKey.
	var r StorageRouter
	shardKey := _hashIStorage(r.RemovePostTimeline(ctx, a0, a1, a2))

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 14, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s iStorage_client_stub) RemoveShortenUrl(ctx context.Context, a0 string) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.removeShortenUrlMetrics.Begin()
	defer func() { s.removeShortenUrlMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IStorage.RemoveShortenUrl", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)

	// Set the shardKey.
	var r StorageRouter
	shardKey := _hashIStorage(r.RemoveShortenUrl(ctx, a0))

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 15, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s iStorage_client_stub) Unfollow(ctx context.Context, a0 int64, a1 int64) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.unfollowMetrics.Begin()
	defer func() { s.unfollowMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IStorage.Unfollow", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.Int64(a1)

	// Set the shardKey.
	var r StorageRouter
	shardKey := _hashIStorage(r.Unfollow(ctx, a0, a1))

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 16, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

type iTextService_client_stub struct {
	stub               codegen.Stub
	composeTextMetrics *codegen.MethodMetrics
}

// Check that iTextService_client_stub implements the ITextService interface.
var _ ITextService = (*iTextService_client_stub)(nil)

func (s iTextService_client_stub) ComposeText(ctx context.Context, a0 string) (r0 TextServiceReturn, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.composeTextMetrics.Begin()
	defer func() { s.composeTextMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.ITextService.ComposeText", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

type iUniqueIdService_client_stub struct {
	stub                   codegen.Stub
	composeUniqueIdMetrics *codegen.MethodMetrics
}

// Check that iUniqueIdService_client_stub implements the IUniqueIdService interface.
var _ IUniqueIdService = (*iUniqueIdService_client_stub)(nil)

func (s iUniqueIdService_client_stub) ComposeUniqueId(ctx context.Context, a0 PostType) (r0 int64, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.composeUniqueIdMetrics.Begin()
	defer func() { s.composeUniqueIdMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IUniqueIdService.ComposeUniqueId", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int((int)(a0))
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.Int64()
	err = dec.Error()
	return
}

type iUrlShortenService_client_stub struct {
	stub                   codegen.Stub
	composeUrlMetrics      *codegen.MethodMetrics
	getExtendedUrlsMetrics *codegen.MethodMetrics
	removeUrlsMetrics      *codegen.MethodMetrics
}

// Check that iUrlShortenService_client_stub implements the IUrlShortenService interface.
var _ IUrlShortenService = (*iUrlShortenService_client_stub)(nil)

func (s iUrlShortenService_client_stub) ComposeUrl(ctx context.Context, a0 []string) (r0 []Url, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.composeUrlMetrics.Begin()
	defer func() { s.composeUrlMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IUrlShortenService.ComposeUrl", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_string_4af10117(enc, a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_Url_b557e127(dec)
	err = dec.Error()
	return
}

func (s iUrlShortenService_client_stub) GetExtendedUrls(ctx context.Context, a0 []string) (r0 []string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getExtendedUrlsMetrics.Begin()
	defer func() { s.getExtendedUrlsMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IUrlShortenService.GetExtendedUrls", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_string_4af10117(enc, a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_string_4af10117(dec)
	err = dec.Error()
	return
}

func (s iUrlShortenService_client_stub) RemoveUrls(ctx context.Context, a0 []string) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.removeUrlsMetrics.Begin()
	defer func() { s.removeUrlsMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IUrlShortenService.RemoveUrls", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_string_4af10117(enc, a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 2, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

type iUserMentionService_client_stub struct {
	stub                       codegen.Stub
	composeUserMentionsMetrics *codegen.MethodMetrics
}

// Check that iUserMentionService_client_stub implements the IUserMentionService interface.
var _ IUserMentionService = (*iUserMentionService_client_stub)(nil)

func (s iUserMentionService_client_stub) ComposeUserMentions(ctx context.Context, a0 []string) (r0 []UserMention, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.composeUserMentionsMetrics.Begin()
	defer func() { s.composeUserMentionsMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IUserMentionService.ComposeUserMentions", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_string_4af10117(enc, a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_UserMention_4c1e0334(dec)
	err = dec.Error()
	return
}

type iUserTimelineService_client_stub struct {
	stub                     codegen.Stub
	readUserTimelineMetrics  *codegen.MethodMetrics
	removePostMetrics        *codegen.MethodMetrics
	writeUserTimelineMetrics *codegen.MethodMetrics
}

// Check that iUserTimelineService_client_stub implements the IUserTimelineService interface.
var _ IUserTimelineService = (*iUserTimelineService_client_stub)(nil)

func (s iUserTimelineService_client_stub) ReadUserTimeline(ctx context.Context, a0 int64, a1 int, a2 int) (r0 []Post, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.readUserTimelineMetrics.Begin()
	defer func() { s.readUserTimelineMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IUserTimelineService.ReadUserTimeline", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += 8
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.Int(a1)
	enc.Int(a2)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_Post_92420d4c(dec)
	err = dec.Error()
	return
}

func (s iUserTimelineService_client_stub) RemovePost(ctx context.Context, a0 int64, a1 int64, a2 int64) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.removePostMetrics.Begin()
	defer func() { s.removePostMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IUserTimelineService.RemovePost", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += 8
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.Int64(a1)
	enc.Int64(a2)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s iUserTimelineService_client_stub) WriteUserTimeline(ctx context.Context, a0 int64, a1 int64, a2 int64) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.writeUserTimelineMetrics.Begin()
	defer func() { s.writeUserTimelineMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.IUserTimelineService.WriteUserTimeline", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += 8
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.Int64(a1)
	enc.Int64(a2)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 2, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

type main_client_stub struct {
	stub codegen.Stub
}

// Check that main_client_stub implements the weaver.Main interface.
var _ weaver.Main = (*main_client_stub)(nil)

type mediaStorageServicer_client_stub struct {
	stub               codegen.Stub
	getMediaMetrics    *codegen.MethodMetrics
	uploadMediaMetrics *codegen.MethodMetrics
}

// Check that mediaStorageServicer_client_stub implements the MediaStorageServicer interface.
var _ MediaStorageServicer = (*mediaStorageServicer_client_stub)(nil)

func (s mediaStorageServicer_client_stub) GetMedia(ctx context.Context, a0 string) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getMediaMetrics.Begin()
	defer func() { s.getMediaMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.MediaStorageServicer.GetMedia", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

func (s mediaStorageServicer_client_stub) UploadMedia(ctx context.Context, a0 string, a1 string) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.uploadMediaMetrics.Begin()
	defer func() { s.uploadMediaMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.MediaStorageServicer.UploadMedia", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

type postStorageServicer_client_stub struct {
	stub              codegen.Stub
	readPostMetrics   *codegen.MethodMetrics
	readPostsMetrics  *codegen.MethodMetrics
	removePostMetrics *codegen.MethodMetrics
	storePostMetrics  *codegen.MethodMetrics
}

// Check that postStorageServicer_client_stub implements the PostStorageServicer interface.
var _ PostStorageServicer = (*postStorageServicer_client_stub)(nil)

func (s postStorageServicer_client_stub) ReadPost(ctx context.Context, a0 int64) (r0 Post, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.readPostMetrics.Begin()
	defer func() { s.readPostMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.PostStorageServicer.ReadPost", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s postStorageServicer_client_stub) ReadPosts(ctx context.Context, a0 []int64) (r0 []Post, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.readPostsMetrics.Begin()
	defer func() { s.readPostsMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.PostStorageServicer.ReadPosts", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + (len(a0) * 8))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	serviceweaver_enc_slice_int64_a8f7f092(enc, a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = serviceweaver_dec_slice_Post_92420d4c(dec)
	err = dec.Error()
	return
}

func (s postStorageServicer_client_stub) RemovePost(ctx context.Context, a0 int64) (r0 bool, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.removePostMetrics.Begin()
	defer func() { s.removePostMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.PostStorageServicer.RemovePost", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 2, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.Bool()
	err = dec.Error()
	return
}

func (s postStorageServicer_client_stub) StorePost(ctx context.Context, a0 Post) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.storePostMetrics.Begin()
	defer func() { s.storePostMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.PostStorageServicer.StorePost", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Encode arguments.
	enc := codegen.NewEncoder()
	(a0).WeaverMarshal(enc)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 3, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

type userServicer_client_stub struct {
	stub                              codegen.Stub
	composeCreatorWithUserIdMetrics   *codegen.MethodMetrics
	composeCreatorWithUsernameMetrics *codegen.MethodMetrics
	getUserIdMetrics                  *codegen.MethodMetrics
	loginMetrics                      *codegen.MethodMetrics
	registerUserMetrics               *codegen.MethodMetrics
	registerUserWithIdMetrics         *codegen.MethodMetrics
}

// Check that userServicer_client_stub implements the UserServicer interface.
var _ UserServicer = (*userServicer_client_stub)(nil)

func (s userServicer_client_stub) ComposeCreatorWithUserId(ctx context.Context, a0 int64, a1 string) (r0 Creator, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.composeCreatorWithUserIdMetrics.Begin()
	defer func() { s.composeCreatorWithUserIdMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.UserServicer.ComposeCreatorWithUserId", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += 8
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.Int64(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 0, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s userServicer_client_stub) ComposeCreatorWithUsername(ctx context.Context, a0 string) (r0 Creator, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.composeCreatorWithUsernameMetrics.Begin()
	defer func() { s.composeCreatorWithUsernameMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.UserServicer.ComposeCreatorWithUsername", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 1, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	(&r0).WeaverUnmarshal(dec)
	err = dec.Error()
	return
}

func (s userServicer_client_stub) GetUserId(ctx context.Context, a0 string) (r0 int64, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.getUserIdMetrics.Begin()
	defer func() { s.getUserIdMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.UserServicer.GetUserId", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 2, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.Int64()
	err = dec.Error()
	return
}

func (s userServicer_client_stub) Login(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.loginMetrics.Begin()
	defer func() { s.loginMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.UserServicer.Login", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 3, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	r0 = dec.String()
	err = dec.Error()
	return
}

func (s userServicer_client_stub) RegisterUser(ctx context.Context, a0 string, a1 string, a2 string, a3 string) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.registerUserMetrics.Begin()
	defer func() { s.registerUserMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.UserServicer.RegisterUser", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	size += (4 + len(a2))
	size += (4 + len(a3))
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	enc.String(a2)
	enc.String(a3)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 4, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

func (s userServicer_client_stub) RegisterUserWithId(ctx context.Context, a0 string, a1 string, a2 string, a3 string, a4 int64) (err error) {
	// Update metrics.
	var requestBytes, replyBytes int
	begin := s.registerUserWithIdMetrics.Begin()
	defer func() { s.registerUserWithIdMetrics.End(begin, err != nil, requestBytes, replyBytes) }()

	span := trace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		// Create a child span for this method.
		ctx, span = s.stub.Tracer().Start(ctx, "main.UserServicer.RegisterUserWithId", trace.WithSpanKind(trace.SpanKindClient))
	}

	defer func() {
		// Catch and return any panics detected during encoding/decoding/rpc.
		if err == nil {
			err = codegen.CatchPanics(recover())
			if err != nil {
				err = errors.Join(weaver.RemoteCallError, err)
			}
		}

		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, err.Error())
		}
		span.End()

	}()

	// Preallocate a buffer of the right size.
	size := 0
	size += (4 + len(a0))
	size += (4 + len(a1))
	size += (4 + len(a2))
	size += (4 + len(a3))
	size += 8
	enc := codegen.NewEncoder()
	enc.Reset(size)

	// Encode arguments.
	enc.String(a0)
	enc.String(a1)
	enc.String(a2)
	enc.String(a3)
	enc.Int64(a4)
	var shardKey uint64

	// Call the remote method.
	requestBytes = len(enc.Data())
	var results []byte
	results, err = s.stub.Run(ctx, 5, enc.Data(), shardKey)
	replyBytes = len(results)
	if err != nil {
		err = errors.Join(weaver.RemoteCallError, err)
		return
	}

	// Decode the results.
	dec := codegen.NewDecoder(results)
	err = dec.Error()
	return
}

// Note that "weaver generate" will always generate the error message below.
// Everything is okay. The error message is only relevant if you see it when
// you run "go build" or "go run".
var _ codegen.LatestVersion = codegen.Version[[0][20]struct{}](`

ERROR: You generated this file with 'weaver generate' v0.22.0 (codegen
version v0.20.0). The generated code is incompatible with the version of the
github.com/ServiceWeaver/weaver module that you're using. The weaver module
version can be found in your go.mod file or by running the following command.

    go list -m github.com/ServiceWeaver/weaver

We recommend updating the weaver module and the 'weaver generate' command by
running the following.

    go get github.com/ServiceWeaver/weaver@latest
    go install github.com/ServiceWeaver/weaver/cmd/weaver@latest

Then, re-run 'weaver generate' and re-build your code. If the problem persists,
please file an issue at https://github.com/ServiceWeaver/weaver/issues.

`)

// Server stub implementations.

type backendServicer_server_stub struct {
	impl    BackendServicer
	addLoad func(key uint64, load float64)
}

// Check that backendServicer_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*backendServicer_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s backendServicer_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "CompostPost":
		return s.compostPost
	case "Follow":
		return s.follow
	case "FollowWithUsername":
		return s.followWithUsername
	case "GetFollowees":
		return s.getFollowees
	case "GetFollowers":
		return s.getFollowers
	case "GetMedia":
		return s.getMedia
	case "Login":
		return s.login
	case "ReadHomeTimeline":
		return s.readHomeTimeline
	case "ReadUserTimeline":
		return s.readUserTimeline
	case "RegisterUser":
		return s.registerUser
	case "RegisterUserWithId":
		return s.registerUserWithId
	case "RemovePosts":
		return s.removePosts
	case "Unfollow":
		return s.unfollow
	case "UnfollowWithUsername":
		return s.unfollowWithUsername
	case "UploadMedia":
		return s.uploadMedia
	default:
		return nil
	}
}

func (s backendServicer_server_stub) compostPost(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 int64
	a1 = dec.Int64()
	var a2 string
	a2 = dec.String()
	var a3 []int64
	a3 = serviceweaver_dec_slice_int64_a8f7f092(dec)
	var a4 []string
	a4 = serviceweaver_dec_slice_string_4af10117(dec)
	var a5 PostType
	*(*int)(&a5) = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.CompostPost(ctx, a0, a1, a2, a3, a4, a5)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s backendServicer_server_stub) follow(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 int64
	a1 = dec.Int64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.Follow(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s backendServicer_server_stub) followWithUsername(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.FollowWithUsername(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s backendServicer_server_stub) getFollowees(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetFollowees(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_int64_a8f7f092(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s backendServicer_server_stub) getFollowers(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetFollowers(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_int64_a8f7f092(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s backendServicer_server_stub) getMedia(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetMedia(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s backendServicer_server_stub) login(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.Login(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s backendServicer_server_stub) readHomeTimeline(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 int
	a1 = dec.Int()
	var a2 int
	a2 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ReadHomeTimeline(ctx, a0, a1, a2)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_Post_92420d4c(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s backendServicer_server_stub) readUserTimeline(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 int
	a1 = dec.Int()
	var a2 int
	a2 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ReadUserTimeline(ctx, a0, a1, a2)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_Post_92420d4c(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s backendServicer_server_stub) registerUser(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()
	var a2 string
	a2 = dec.String()
	var a3 string
	a3 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.RegisterUser(ctx, a0, a1, a2, a3)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s backendServicer_server_stub) registerUserWithId(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()
	var a2 string
	a2 = dec.String()
	var a3 string
	a3 = dec.String()
	var a4 int64
	a4 = dec.Int64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.RegisterUserWithId(ctx, a0, a1, a2, a3, a4)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s backendServicer_server_stub) removePosts(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 int
	a1 = dec.Int()
	var a2 int
	a2 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.RemovePosts(ctx, a0, a1, a2)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s backendServicer_server_stub) unfollow(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 int64
	a1 = dec.Int64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.Unfollow(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s backendServicer_server_stub) unfollowWithUsername(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.UnfollowWithUsername(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s backendServicer_server_stub) uploadMedia(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.UploadMedia(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

type iHomeTimelineService_server_stub struct {
	impl    IHomeTimelineService
	addLoad func(key uint64, load float64)
}

// Check that iHomeTimelineService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*iHomeTimelineService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s iHomeTimelineService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "ReadHomeTimeline":
		return s.readHomeTimeline
	case "RemovePost":
		return s.removePost
	case "WriteHomeTimeline":
		return s.writeHomeTimeline
	default:
		return nil
	}
}

func (s iHomeTimelineService_server_stub) readHomeTimeline(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 int
	a1 = dec.Int()
	var a2 int
	a2 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ReadHomeTimeline(ctx, a0, a1, a2)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_Post_92420d4c(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iHomeTimelineService_server_stub) removePost(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 int64
	a1 = dec.Int64()
	var a2 int64
	a2 = dec.Int64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.RemovePost(ctx, a0, a1, a2)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iHomeTimelineService_server_stub) writeHomeTimeline(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 int64
	a1 = dec.Int64()
	var a2 int64
	a2 = dec.Int64()
	var a3 []int64
	a3 = serviceweaver_dec_slice_int64_a8f7f092(dec)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.WriteHomeTimeline(ctx, a0, a1, a2, a3)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

type iMediaService_server_stub struct {
	impl    IMediaService
	addLoad func(key uint64, load float64)
}

// Check that iMediaService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*iMediaService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s iMediaService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "ComposeMedia":
		return s.composeMedia
	default:
		return nil
	}
}

func (s iMediaService_server_stub) composeMedia(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 []string
	a0 = serviceweaver_dec_slice_string_4af10117(dec)
	var a1 []int64
	a1 = serviceweaver_dec_slice_int64_a8f7f092(dec)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ComposeMedia(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_Media_7ba3b576(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

type iSocialGraphService_server_stub struct {
	impl    ISocialGraphService
	addLoad func(key uint64, load float64)
}

// Check that iSocialGraphService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*iSocialGraphService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s iSocialGraphService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "Follow":
		return s.follow
	case "FollowWithUsername":
		return s.followWithUsername
	case "GetFollowees":
		return s.getFollowees
	case "GetFollowers":
		return s.getFollowers
	case "Unfollow":
		return s.unfollow
	case "UnfollowWithUsername":
		return s.unfollowWithUsername
	default:
		return nil
	}
}

func (s iSocialGraphService_server_stub) follow(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 int64
	a1 = dec.Int64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.Follow(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iSocialGraphService_server_stub) followWithUsername(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.FollowWithUsername(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iSocialGraphService_server_stub) getFollowees(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetFollowees(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_int64_a8f7f092(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iSocialGraphService_server_stub) getFollowers(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetFollowers(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_int64_a8f7f092(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iSocialGraphService_server_stub) unfollow(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 int64
	a1 = dec.Int64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.Unfollow(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iSocialGraphService_server_stub) unfollowWithUsername(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.UnfollowWithUsername(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

type iStorage_server_stub struct {
	impl    IStorage
	addLoad func(key uint64, load float64)
}

// Check that iStorage_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*iStorage_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s iStorage_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "Follow":
		return s.follow
	case "GetFollowees":
		return s.getFollowees
	case "GetFollowers":
		return s.getFollowers
	case "GetMediaData":
		return s.getMediaData
	case "GetPost":
		return s.getPost
	case "GetPostTimeline":
		return s.getPostTimeline
	case "GetShortenUrl":
		return s.getShortenUrl
	case "GetUserProfile":
		return s.getUserProfile
	case "PutMediaData":
		return s.putMediaData
	case "PutPost":
		return s.putPost
	case "PutPostTimeline":
		return s.putPostTimeline
	case "PutShortenUrl":
		return s.putShortenUrl
	case "PutUserProfile":
		return s.putUserProfile
	case "RemovePost":
		return s.removePost
	case "RemovePostTimeline":
		return s.removePostTimeline
	case "RemoveShortenUrl":
		return s.removeShortenUrl
	case "Unfollow":
		return s.unfollow
	default:
		return nil
	}
}

func (s iStorage_server_stub) follow(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 int64
	a1 = dec.Int64()
	var r StorageRouter
	s.addLoad(_hashIStorage(r.Follow(ctx, a0, a1)), 1.0)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.Follow(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iStorage_server_stub) getFollowees(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var r StorageRouter
	s.addLoad(_hashIStorage(r.GetFollowees(ctx, a0)), 1.0)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, r1, appErr := s.impl.GetFollowees(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_map_int64_bool_7caa5f14(enc, r0)
	enc.Bool(r1)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iStorage_server_stub) getFollowers(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var r StorageRouter
	s.addLoad(_hashIStorage(r.GetFollowers(ctx, a0)), 1.0)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, r1, appErr := s.impl.GetFollowers(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_map_int64_bool_7caa5f14(enc, r0)
	enc.Bool(r1)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iStorage_server_stub) getMediaData(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var r StorageRouter
	s.addLoad(_hashIStorage(r.GetMediaData(ctx, a0)), 1.0)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, r1, appErr := s.impl.GetMediaData(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Bool(r1)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iStorage_server_stub) getPost(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var r StorageRouter
	s.addLoad(_hashIStorage(r.GetPost(ctx, a0)), 1.0)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, r1, appErr := s.impl.GetPost(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Bool(r1)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iStorage_server_stub) getPostTimeline(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 int
	a1 = dec.Int()
	var a2 int
	a2 = dec.Int()
	var r StorageRouter
	s.addLoad(_hashIStorage(r.GetPostTimeline(ctx, a0, a1, a2)), 1.0)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetPostTimeline(ctx, a0, a1, a2)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_int64_a8f7f092(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iStorage_server_stub) getShortenUrl(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var r StorageRouter
	s.addLoad(_hashIStorage(r.GetShortenUrl(ctx, a0)), 1.0)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, r1, appErr := s.impl.GetShortenUrl(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Bool(r1)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iStorage_server_stub) getUserProfile(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var r StorageRouter
	s.addLoad(_hashIStorage(r.GetUserProfile(ctx, a0)), 1.0)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, r1, appErr := s.impl.GetUserProfile(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Bool(r1)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iStorage_server_stub) putMediaData(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()
	var r StorageRouter
	s.addLoad(_hashIStorage(r.PutMediaData(ctx, a0, a1)), 1.0)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.PutMediaData(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iStorage_server_stub) putPost(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 Post
	(&a1).WeaverUnmarshal(dec)
	var r StorageRouter
	s.addLoad(_hashIStorage(r.PutPost(ctx, a0, a1)), 1.0)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.PutPost(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iStorage_server_stub) putPostTimeline(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 int64
	a1 = dec.Int64()
	var a2 int64
	a2 = dec.Int64()
	var r StorageRouter
	s.addLoad(_hashIStorage(r.PutPostTimeline(ctx, a0, a1, a2)), 1.0)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.PutPostTimeline(ctx, a0, a1, a2)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iStorage_server_stub) putShortenUrl(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()
	var r StorageRouter
	s.addLoad(_hashIStorage(r.PutShortenUrl(ctx, a0, a1)), 1.0)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.PutShortenUrl(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iStorage_server_stub) putUserProfile(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 UserProfile
	(&a1).WeaverUnmarshal(dec)
	var r StorageRouter
	s.addLoad(_hashIStorage(r.PutUserProfile(ctx, a0, a1)), 1.0)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.PutUserProfile(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iStorage_server_stub) removePost(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var r StorageRouter
	s.addLoad(_hashIStorage(r.RemovePost(ctx, a0)), 1.0)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.RemovePost(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Bool(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iStorage_server_stub) removePostTimeline(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 int64
	a1 = dec.Int64()
	var a2 int64
	a2 = dec.Int64()
	var r StorageRouter
	s.addLoad(_hashIStorage(r.RemovePostTimeline(ctx, a0, a1, a2)), 1.0)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.RemovePostTimeline(ctx, a0, a1, a2)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iStorage_server_stub) removeShortenUrl(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var r StorageRouter
	s.addLoad(_hashIStorage(r.RemoveShortenUrl(ctx, a0)), 1.0)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.RemoveShortenUrl(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iStorage_server_stub) unfollow(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 int64
	a1 = dec.Int64()
	var r StorageRouter
	s.addLoad(_hashIStorage(r.Unfollow(ctx, a0, a1)), 1.0)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.Unfollow(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

type iTextService_server_stub struct {
	impl    ITextService
	addLoad func(key uint64, load float64)
}

// Check that iTextService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*iTextService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s iTextService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "ComposeText":
		return s.composeText
	default:
		return nil
	}
}

func (s iTextService_server_stub) composeText(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ComposeText(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

type iUniqueIdService_server_stub struct {
	impl    IUniqueIdService
	addLoad func(key uint64, load float64)
}

// Check that iUniqueIdService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*iUniqueIdService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s iUniqueIdService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "ComposeUniqueId":
		return s.composeUniqueId
	default:
		return nil
	}
}

func (s iUniqueIdService_server_stub) composeUniqueId(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 PostType
	*(*int)(&a0) = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ComposeUniqueId(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Int64(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

type iUrlShortenService_server_stub struct {
	impl    IUrlShortenService
	addLoad func(key uint64, load float64)
}

// Check that iUrlShortenService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*iUrlShortenService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s iUrlShortenService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "ComposeUrl":
		return s.composeUrl
	case "GetExtendedUrls":
		return s.getExtendedUrls
	case "RemoveUrls":
		return s.removeUrls
	default:
		return nil
	}
}

func (s iUrlShortenService_server_stub) composeUrl(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 []string
	a0 = serviceweaver_dec_slice_string_4af10117(dec)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ComposeUrl(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_Url_b557e127(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iUrlShortenService_server_stub) getExtendedUrls(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 []string
	a0 = serviceweaver_dec_slice_string_4af10117(dec)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetExtendedUrls(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_string_4af10117(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iUrlShortenService_server_stub) removeUrls(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 []string
	a0 = serviceweaver_dec_slice_string_4af10117(dec)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.RemoveUrls(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

type iUserMentionService_server_stub struct {
	impl    IUserMentionService
	addLoad func(key uint64, load float64)
}

// Check that iUserMentionService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*iUserMentionService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s iUserMentionService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "ComposeUserMentions":
		return s.composeUserMentions
	default:
		return nil
	}
}

func (s iUserMentionService_server_stub) composeUserMentions(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 []string
	a0 = serviceweaver_dec_slice_string_4af10117(dec)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ComposeUserMentions(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_UserMention_4c1e0334(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

type iUserTimelineService_server_stub struct {
	impl    IUserTimelineService
	addLoad func(key uint64, load float64)
}

// Check that iUserTimelineService_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*iUserTimelineService_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s iUserTimelineService_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "ReadUserTimeline":
		return s.readUserTimeline
	case "RemovePost":
		return s.removePost
	case "WriteUserTimeline":
		return s.writeUserTimeline
	default:
		return nil
	}
}

func (s iUserTimelineService_server_stub) readUserTimeline(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 int
	a1 = dec.Int()
	var a2 int
	a2 = dec.Int()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ReadUserTimeline(ctx, a0, a1, a2)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_Post_92420d4c(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iUserTimelineService_server_stub) removePost(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 int64
	a1 = dec.Int64()
	var a2 int64
	a2 = dec.Int64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.RemovePost(ctx, a0, a1, a2)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s iUserTimelineService_server_stub) writeUserTimeline(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 int64
	a1 = dec.Int64()
	var a2 int64
	a2 = dec.Int64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.WriteUserTimeline(ctx, a0, a1, a2)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

type main_server_stub struct {
	impl    weaver.Main
	addLoad func(key uint64, load float64)
}

// Check that main_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*main_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s main_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	default:
		return nil
	}
}

type mediaStorageServicer_server_stub struct {
	impl    MediaStorageServicer
	addLoad func(key uint64, load float64)
}

// Check that mediaStorageServicer_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*mediaStorageServicer_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s mediaStorageServicer_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "GetMedia":
		return s.getMedia
	case "UploadMedia":
		return s.uploadMedia
	default:
		return nil
	}
}

func (s mediaStorageServicer_server_stub) getMedia(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetMedia(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s mediaStorageServicer_server_stub) uploadMedia(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.UploadMedia(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

type postStorageServicer_server_stub struct {
	impl    PostStorageServicer
	addLoad func(key uint64, load float64)
}

// Check that postStorageServicer_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*postStorageServicer_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s postStorageServicer_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "ReadPost":
		return s.readPost
	case "ReadPosts":
		return s.readPosts
	case "RemovePost":
		return s.removePost
	case "StorePost":
		return s.storePost
	default:
		return nil
	}
}

func (s postStorageServicer_server_stub) readPost(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ReadPost(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s postStorageServicer_server_stub) readPosts(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 []int64
	a0 = serviceweaver_dec_slice_int64_a8f7f092(dec)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ReadPosts(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	serviceweaver_enc_slice_Post_92420d4c(enc, r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s postStorageServicer_server_stub) removePost(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.RemovePost(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Bool(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s postStorageServicer_server_stub) storePost(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 Post
	(&a0).WeaverUnmarshal(dec)

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.StorePost(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

type userServicer_server_stub struct {
	impl    UserServicer
	addLoad func(key uint64, load float64)
}

// Check that userServicer_server_stub implements the codegen.Server interface.
var _ codegen.Server = (*userServicer_server_stub)(nil)

// GetStubFn implements the codegen.Server interface.
func (s userServicer_server_stub) GetStubFn(method string) func(ctx context.Context, args []byte) ([]byte, error) {
	switch method {
	case "ComposeCreatorWithUserId":
		return s.composeCreatorWithUserId
	case "ComposeCreatorWithUsername":
		return s.composeCreatorWithUsername
	case "GetUserId":
		return s.getUserId
	case "Login":
		return s.login
	case "RegisterUser":
		return s.registerUser
	case "RegisterUserWithId":
		return s.registerUserWithId
	default:
		return nil
	}
}

func (s userServicer_server_stub) composeCreatorWithUserId(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 int64
	a0 = dec.Int64()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ComposeCreatorWithUserId(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s userServicer_server_stub) composeCreatorWithUsername(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.ComposeCreatorWithUsername(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	(r0).WeaverMarshal(enc)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s userServicer_server_stub) getUserId(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.GetUserId(ctx, a0)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Int64(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s userServicer_server_stub) login(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	r0, appErr := s.impl.Login(ctx, a0, a1)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.String(r0)
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s userServicer_server_stub) registerUser(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()
	var a2 string
	a2 = dec.String()
	var a3 string
	a3 = dec.String()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.RegisterUser(ctx, a0, a1, a2, a3)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

func (s userServicer_server_stub) registerUserWithId(ctx context.Context, args []byte) (res []byte, err error) {
	// Catch and return any panics detected during encoding/decoding/rpc.
	defer func() {
		if err == nil {
			err = codegen.CatchPanics(recover())
		}
	}()

	// Decode arguments.
	dec := codegen.NewDecoder(args)
	var a0 string
	a0 = dec.String()
	var a1 string
	a1 = dec.String()
	var a2 string
	a2 = dec.String()
	var a3 string
	a3 = dec.String()
	var a4 int64
	a4 = dec.Int64()

	// TODO(rgrandl): The deferred function above will recover from panics in the
	// user code: fix this.
	// Call the local method.
	appErr := s.impl.RegisterUserWithId(ctx, a0, a1, a2, a3, a4)

	// Encode the results.
	enc := codegen.NewEncoder()
	enc.Error(appErr)
	return enc.Data(), nil
}

// Reflect stub implementations.

type backendServicer_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that backendServicer_reflect_stub implements the BackendServicer interface.
var _ BackendServicer = (*backendServicer_reflect_stub)(nil)

func (s backendServicer_reflect_stub) CompostPost(ctx context.Context, a0 string, a1 int64, a2 string, a3 []int64, a4 []string, a5 PostType) (err error) {
	err = s.caller("CompostPost", ctx, []any{a0, a1, a2, a3, a4, a5}, []any{})
	return
}

func (s backendServicer_reflect_stub) Follow(ctx context.Context, a0 int64, a1 int64) (err error) {
	err = s.caller("Follow", ctx, []any{a0, a1}, []any{})
	return
}

func (s backendServicer_reflect_stub) FollowWithUsername(ctx context.Context, a0 string, a1 string) (err error) {
	err = s.caller("FollowWithUsername", ctx, []any{a0, a1}, []any{})
	return
}

func (s backendServicer_reflect_stub) GetFollowees(ctx context.Context, a0 int64) (r0 []int64, err error) {
	err = s.caller("GetFollowees", ctx, []any{a0}, []any{&r0})
	return
}

func (s backendServicer_reflect_stub) GetFollowers(ctx context.Context, a0 int64) (r0 []int64, err error) {
	err = s.caller("GetFollowers", ctx, []any{a0}, []any{&r0})
	return
}

func (s backendServicer_reflect_stub) GetMedia(ctx context.Context, a0 string) (r0 string, err error) {
	err = s.caller("GetMedia", ctx, []any{a0}, []any{&r0})
	return
}

func (s backendServicer_reflect_stub) Login(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	err = s.caller("Login", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s backendServicer_reflect_stub) ReadHomeTimeline(ctx context.Context, a0 int64, a1 int, a2 int) (r0 []Post, err error) {
	err = s.caller("ReadHomeTimeline", ctx, []any{a0, a1, a2}, []any{&r0})
	return
}

func (s backendServicer_reflect_stub) ReadUserTimeline(ctx context.Context, a0 int64, a1 int, a2 int) (r0 []Post, err error) {
	err = s.caller("ReadUserTimeline", ctx, []any{a0, a1, a2}, []any{&r0})
	return
}

func (s backendServicer_reflect_stub) RegisterUser(ctx context.Context, a0 string, a1 string, a2 string, a3 string) (err error) {
	err = s.caller("RegisterUser", ctx, []any{a0, a1, a2, a3}, []any{})
	return
}

func (s backendServicer_reflect_stub) RegisterUserWithId(ctx context.Context, a0 string, a1 string, a2 string, a3 string, a4 int64) (err error) {
	err = s.caller("RegisterUserWithId", ctx, []any{a0, a1, a2, a3, a4}, []any{})
	return
}

func (s backendServicer_reflect_stub) RemovePosts(ctx context.Context, a0 int64, a1 int, a2 int) (err error) {
	err = s.caller("RemovePosts", ctx, []any{a0, a1, a2}, []any{})
	return
}

func (s backendServicer_reflect_stub) Unfollow(ctx context.Context, a0 int64, a1 int64) (err error) {
	err = s.caller("Unfollow", ctx, []any{a0, a1}, []any{})
	return
}

func (s backendServicer_reflect_stub) UnfollowWithUsername(ctx context.Context, a0 string, a1 string) (err error) {
	err = s.caller("UnfollowWithUsername", ctx, []any{a0, a1}, []any{})
	return
}

func (s backendServicer_reflect_stub) UploadMedia(ctx context.Context, a0 string, a1 string) (err error) {
	err = s.caller("UploadMedia", ctx, []any{a0, a1}, []any{})
	return
}

type iHomeTimelineService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that iHomeTimelineService_reflect_stub implements the IHomeTimelineService interface.
var _ IHomeTimelineService = (*iHomeTimelineService_reflect_stub)(nil)

func (s iHomeTimelineService_reflect_stub) ReadHomeTimeline(ctx context.Context, a0 int64, a1 int, a2 int) (r0 []Post, err error) {
	err = s.caller("ReadHomeTimeline", ctx, []any{a0, a1, a2}, []any{&r0})
	return
}

func (s iHomeTimelineService_reflect_stub) RemovePost(ctx context.Context, a0 int64, a1 int64, a2 int64) (err error) {
	err = s.caller("RemovePost", ctx, []any{a0, a1, a2}, []any{})
	return
}

func (s iHomeTimelineService_reflect_stub) WriteHomeTimeline(ctx context.Context, a0 int64, a1 int64, a2 int64, a3 []int64) (err error) {
	err = s.caller("WriteHomeTimeline", ctx, []any{a0, a1, a2, a3}, []any{})
	return
}

type iMediaService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that iMediaService_reflect_stub implements the IMediaService interface.
var _ IMediaService = (*iMediaService_reflect_stub)(nil)

func (s iMediaService_reflect_stub) ComposeMedia(ctx context.Context, a0 []string, a1 []int64) (r0 []Media, err error) {
	err = s.caller("ComposeMedia", ctx, []any{a0, a1}, []any{&r0})
	return
}

type iSocialGraphService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that iSocialGraphService_reflect_stub implements the ISocialGraphService interface.
var _ ISocialGraphService = (*iSocialGraphService_reflect_stub)(nil)

func (s iSocialGraphService_reflect_stub) Follow(ctx context.Context, a0 int64, a1 int64) (err error) {
	err = s.caller("Follow", ctx, []any{a0, a1}, []any{})
	return
}

func (s iSocialGraphService_reflect_stub) FollowWithUsername(ctx context.Context, a0 string, a1 string) (err error) {
	err = s.caller("FollowWithUsername", ctx, []any{a0, a1}, []any{})
	return
}

func (s iSocialGraphService_reflect_stub) GetFollowees(ctx context.Context, a0 int64) (r0 []int64, err error) {
	err = s.caller("GetFollowees", ctx, []any{a0}, []any{&r0})
	return
}

func (s iSocialGraphService_reflect_stub) GetFollowers(ctx context.Context, a0 int64) (r0 []int64, err error) {
	err = s.caller("GetFollowers", ctx, []any{a0}, []any{&r0})
	return
}

func (s iSocialGraphService_reflect_stub) Unfollow(ctx context.Context, a0 int64, a1 int64) (err error) {
	err = s.caller("Unfollow", ctx, []any{a0, a1}, []any{})
	return
}

func (s iSocialGraphService_reflect_stub) UnfollowWithUsername(ctx context.Context, a0 string, a1 string) (err error) {
	err = s.caller("UnfollowWithUsername", ctx, []any{a0, a1}, []any{})
	return
}

type iStorage_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that iStorage_reflect_stub implements the IStorage interface.
var _ IStorage = (*iStorage_reflect_stub)(nil)

func (s iStorage_reflect_stub) Follow(ctx context.Context, a0 int64, a1 int64) (err error) {
	err = s.caller("Follow", ctx, []any{a0, a1}, []any{})
	return
}

func (s iStorage_reflect_stub) GetFollowees(ctx context.Context, a0 int64) (r0 map[int64]bool, r1 bool, err error) {
	err = s.caller("GetFollowees", ctx, []any{a0}, []any{&r0, &r1})
	return
}

func (s iStorage_reflect_stub) GetFollowers(ctx context.Context, a0 int64) (r0 map[int64]bool, r1 bool, err error) {
	err = s.caller("GetFollowers", ctx, []any{a0}, []any{&r0, &r1})
	return
}

func (s iStorage_reflect_stub) GetMediaData(ctx context.Context, a0 string) (r0 string, r1 bool, err error) {
	err = s.caller("GetMediaData", ctx, []any{a0}, []any{&r0, &r1})
	return
}

func (s iStorage_reflect_stub) GetPost(ctx context.Context, a0 int64) (r0 Post, r1 bool, err error) {
	err = s.caller("GetPost", ctx, []any{a0}, []any{&r0, &r1})
	return
}

func (s iStorage_reflect_stub) GetPostTimeline(ctx context.Context, a0 int64, a1 int, a2 int) (r0 []int64, err error) {
	err = s.caller("GetPostTimeline", ctx, []any{a0, a1, a2}, []any{&r0})
	return
}

func (s iStorage_reflect_stub) GetShortenUrl(ctx context.Context, a0 string) (r0 string, r1 bool, err error) {
	err = s.caller("GetShortenUrl", ctx, []any{a0}, []any{&r0, &r1})
	return
}

func (s iStorage_reflect_stub) GetUserProfile(ctx context.Context, a0 string) (r0 UserProfile, r1 bool, err error) {
	err = s.caller("GetUserProfile", ctx, []any{a0}, []any{&r0, &r1})
	return
}

func (s iStorage_reflect_stub) PutMediaData(ctx context.Context, a0 string, a1 string) (err error) {
	err = s.caller("PutMediaData", ctx, []any{a0, a1}, []any{})
	return
}

func (s iStorage_reflect_stub) PutPost(ctx context.Context, a0 int64, a1 Post) (err error) {
	err = s.caller("PutPost", ctx, []any{a0, a1}, []any{})
	return
}

func (s iStorage_reflect_stub) PutPostTimeline(ctx context.Context, a0 int64, a1 int64, a2 int64) (err error) {
	err = s.caller("PutPostTimeline", ctx, []any{a0, a1, a2}, []any{})
	return
}

func (s iStorage_reflect_stub) PutShortenUrl(ctx context.Context, a0 string, a1 string) (err error) {
	err = s.caller("PutShortenUrl", ctx, []any{a0, a1}, []any{})
	return
}

func (s iStorage_reflect_stub) PutUserProfile(ctx context.Context, a0 string, a1 UserProfile) (err error) {
	err = s.caller("PutUserProfile", ctx, []any{a0, a1}, []any{})
	return
}

func (s iStorage_reflect_stub) RemovePost(ctx context.Context, a0 int64) (r0 bool, err error) {
	err = s.caller("RemovePost", ctx, []any{a0}, []any{&r0})
	return
}

func (s iStorage_reflect_stub) RemovePostTimeline(ctx context.Context, a0 int64, a1 int64, a2 int64) (err error) {
	err = s.caller("RemovePostTimeline", ctx, []any{a0, a1, a2}, []any{})
	return
}

func (s iStorage_reflect_stub) RemoveShortenUrl(ctx context.Context, a0 string) (err error) {
	err = s.caller("RemoveShortenUrl", ctx, []any{a0}, []any{})
	return
}

func (s iStorage_reflect_stub) Unfollow(ctx context.Context, a0 int64, a1 int64) (err error) {
	err = s.caller("Unfollow", ctx, []any{a0, a1}, []any{})
	return
}

type iTextService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that iTextService_reflect_stub implements the ITextService interface.
var _ ITextService = (*iTextService_reflect_stub)(nil)

func (s iTextService_reflect_stub) ComposeText(ctx context.Context, a0 string) (r0 TextServiceReturn, err error) {
	err = s.caller("ComposeText", ctx, []any{a0}, []any{&r0})
	return
}

type iUniqueIdService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that iUniqueIdService_reflect_stub implements the IUniqueIdService interface.
var _ IUniqueIdService = (*iUniqueIdService_reflect_stub)(nil)

func (s iUniqueIdService_reflect_stub) ComposeUniqueId(ctx context.Context, a0 PostType) (r0 int64, err error) {
	err = s.caller("ComposeUniqueId", ctx, []any{a0}, []any{&r0})
	return
}

type iUrlShortenService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that iUrlShortenService_reflect_stub implements the IUrlShortenService interface.
var _ IUrlShortenService = (*iUrlShortenService_reflect_stub)(nil)

func (s iUrlShortenService_reflect_stub) ComposeUrl(ctx context.Context, a0 []string) (r0 []Url, err error) {
	err = s.caller("ComposeUrl", ctx, []any{a0}, []any{&r0})
	return
}

func (s iUrlShortenService_reflect_stub) GetExtendedUrls(ctx context.Context, a0 []string) (r0 []string, err error) {
	err = s.caller("GetExtendedUrls", ctx, []any{a0}, []any{&r0})
	return
}

func (s iUrlShortenService_reflect_stub) RemoveUrls(ctx context.Context, a0 []string) (err error) {
	err = s.caller("RemoveUrls", ctx, []any{a0}, []any{})
	return
}

type iUserMentionService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that iUserMentionService_reflect_stub implements the IUserMentionService interface.
var _ IUserMentionService = (*iUserMentionService_reflect_stub)(nil)

func (s iUserMentionService_reflect_stub) ComposeUserMentions(ctx context.Context, a0 []string) (r0 []UserMention, err error) {
	err = s.caller("ComposeUserMentions", ctx, []any{a0}, []any{&r0})
	return
}

type iUserTimelineService_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that iUserTimelineService_reflect_stub implements the IUserTimelineService interface.
var _ IUserTimelineService = (*iUserTimelineService_reflect_stub)(nil)

func (s iUserTimelineService_reflect_stub) ReadUserTimeline(ctx context.Context, a0 int64, a1 int, a2 int) (r0 []Post, err error) {
	err = s.caller("ReadUserTimeline", ctx, []any{a0, a1, a2}, []any{&r0})
	return
}

func (s iUserTimelineService_reflect_stub) RemovePost(ctx context.Context, a0 int64, a1 int64, a2 int64) (err error) {
	err = s.caller("RemovePost", ctx, []any{a0, a1, a2}, []any{})
	return
}

func (s iUserTimelineService_reflect_stub) WriteUserTimeline(ctx context.Context, a0 int64, a1 int64, a2 int64) (err error) {
	err = s.caller("WriteUserTimeline", ctx, []any{a0, a1, a2}, []any{})
	return
}

type main_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that main_reflect_stub implements the weaver.Main interface.
var _ weaver.Main = (*main_reflect_stub)(nil)

type mediaStorageServicer_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that mediaStorageServicer_reflect_stub implements the MediaStorageServicer interface.
var _ MediaStorageServicer = (*mediaStorageServicer_reflect_stub)(nil)

func (s mediaStorageServicer_reflect_stub) GetMedia(ctx context.Context, a0 string) (r0 string, err error) {
	err = s.caller("GetMedia", ctx, []any{a0}, []any{&r0})
	return
}

func (s mediaStorageServicer_reflect_stub) UploadMedia(ctx context.Context, a0 string, a1 string) (err error) {
	err = s.caller("UploadMedia", ctx, []any{a0, a1}, []any{})
	return
}

type postStorageServicer_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that postStorageServicer_reflect_stub implements the PostStorageServicer interface.
var _ PostStorageServicer = (*postStorageServicer_reflect_stub)(nil)

func (s postStorageServicer_reflect_stub) ReadPost(ctx context.Context, a0 int64) (r0 Post, err error) {
	err = s.caller("ReadPost", ctx, []any{a0}, []any{&r0})
	return
}

func (s postStorageServicer_reflect_stub) ReadPosts(ctx context.Context, a0 []int64) (r0 []Post, err error) {
	err = s.caller("ReadPosts", ctx, []any{a0}, []any{&r0})
	return
}

func (s postStorageServicer_reflect_stub) RemovePost(ctx context.Context, a0 int64) (r0 bool, err error) {
	err = s.caller("RemovePost", ctx, []any{a0}, []any{&r0})
	return
}

func (s postStorageServicer_reflect_stub) StorePost(ctx context.Context, a0 Post) (err error) {
	err = s.caller("StorePost", ctx, []any{a0}, []any{})
	return
}

type userServicer_reflect_stub struct {
	caller func(string, context.Context, []any, []any) error
}

// Check that userServicer_reflect_stub implements the UserServicer interface.
var _ UserServicer = (*userServicer_reflect_stub)(nil)

func (s userServicer_reflect_stub) ComposeCreatorWithUserId(ctx context.Context, a0 int64, a1 string) (r0 Creator, err error) {
	err = s.caller("ComposeCreatorWithUserId", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s userServicer_reflect_stub) ComposeCreatorWithUsername(ctx context.Context, a0 string) (r0 Creator, err error) {
	err = s.caller("ComposeCreatorWithUsername", ctx, []any{a0}, []any{&r0})
	return
}

func (s userServicer_reflect_stub) GetUserId(ctx context.Context, a0 string) (r0 int64, err error) {
	err = s.caller("GetUserId", ctx, []any{a0}, []any{&r0})
	return
}

func (s userServicer_reflect_stub) Login(ctx context.Context, a0 string, a1 string) (r0 string, err error) {
	err = s.caller("Login", ctx, []any{a0, a1}, []any{&r0})
	return
}

func (s userServicer_reflect_stub) RegisterUser(ctx context.Context, a0 string, a1 string, a2 string, a3 string) (err error) {
	err = s.caller("RegisterUser", ctx, []any{a0, a1, a2, a3}, []any{})
	return
}

func (s userServicer_reflect_stub) RegisterUserWithId(ctx context.Context, a0 string, a1 string, a2 string, a3 string, a4 int64) (err error) {
	err = s.caller("RegisterUserWithId", ctx, []any{a0, a1, a2, a3, a4}, []any{})
	return
}

// AutoMarshal implementations.

var _ codegen.AutoMarshal = (*Creator)(nil)

type __is_Creator[T ~struct {
	weaver.AutoMarshal
	UserId   int64
	Username string
}] struct{}

var _ __is_Creator[Creator]

func (x *Creator) WeaverMarshal(enc *codegen.Encoder) {
	if x == nil {
		panic(fmt.Errorf("Creator.WeaverMarshal: nil receiver"))
	}
	enc.Int64(x.UserId)
	enc.String(x.Username)
}

func (x *Creator) WeaverUnmarshal(dec *codegen.Decoder) {
	if x == nil {
		panic(fmt.Errorf("Creator.WeaverUnmarshal: nil receiver"))
	}
	x.UserId = dec.Int64()
	x.Username = dec.String()
}

var _ codegen.AutoMarshal = (*Media)(nil)

type __is_Media[T ~struct {
	weaver.AutoMarshal
	MediaId   int64
	MediaType string
}] struct{}

var _ __is_Media[Media]

func (x *Media) WeaverMarshal(enc *codegen.Encoder) {
	if x == nil {
		panic(fmt.Errorf("Media.WeaverMarshal: nil receiver"))
	}
	enc.Int64(x.MediaId)
	enc.String(x.MediaType)
}

func (x *Media) WeaverUnmarshal(dec *codegen.Decoder) {
	if x == nil {
		panic(fmt.Errorf("Media.WeaverUnmarshal: nil receiver"))
	}
	x.MediaId = dec.Int64()
	x.MediaType = dec.String()
}

var _ codegen.AutoMarshal = (*Post)(nil)

type __is_Post[T ~struct {
	weaver.AutoMarshal
	Post_id       int64
	Creator       Creator
	Req_id        int64
	Text          string
	User_mentions []UserMention
	Media         []Media
	Urls          []Url
	Timestamp     int64
	Post_type     PostType
}] struct{}

var _ __is_Post[Post]

func (x *Post) WeaverMarshal(enc *codegen.Encoder) {
	if x == nil {
		panic(fmt.Errorf("Post.WeaverMarshal: nil receiver"))
	}
	enc.Int64(x.Post_id)
	(x.Creator).WeaverMarshal(enc)
	enc.Int64(x.Req_id)
	enc.String(x.Text)
	serviceweaver_enc_slice_UserMention_4c1e0334(enc, x.User_mentions)
	serviceweaver_enc_slice_Media_7ba3b576(enc, x.Media)
	serviceweaver_enc_slice_Url_b557e127(enc, x.Urls)
	enc.Int64(x.Timestamp)
	enc.Int((int)(x.Post_type))
}

func (x *Post) WeaverUnmarshal(dec *codegen.Decoder) {
	if x == nil {
		panic(fmt.Errorf("Post.WeaverUnmarshal: nil receiver"))
	}
	x.Post_id = dec.Int64()
	(&x.Creator).WeaverUnmarshal(dec)
	x.Req_id = dec.Int64()
	x.Text = dec.String()
	x.User_mentions = serviceweaver_dec_slice_UserMention_4c1e0334(dec)
	x.Media = serviceweaver_dec_slice_Media_7ba3b576(dec)
	x.Urls = serviceweaver_dec_slice_Url_b557e127(dec)
	x.Timestamp = dec.Int64()
	*(*int)(&x.Post_type) = dec.Int()
}

func serviceweaver_enc_slice_UserMention_4c1e0334(enc *codegen.Encoder, arg []UserMention) {
	if arg == nil {
		enc.Len(-1)
		return
	}
	enc.Len(len(arg))
	for i := 0; i < len(arg); i++ {
		(arg[i]).WeaverMarshal(enc)
	}
}

func serviceweaver_dec_slice_UserMention_4c1e0334(dec *codegen.Decoder) []UserMention {
	n := dec.Len()
	if n == -1 {
		return nil
	}
	res := make([]UserMention, n)
	for i := 0; i < n; i++ {
		(&res[i]).WeaverUnmarshal(dec)
	}
	return res
}

func serviceweaver_enc_slice_Media_7ba3b576(enc *codegen.Encoder, arg []Media) {
	if arg == nil {
		enc.Len(-1)
		return
	}
	enc.Len(len(arg))
	for i := 0; i < len(arg); i++ {
		(arg[i]).WeaverMarshal(enc)
	}
}

func serviceweaver_dec_slice_Media_7ba3b576(dec *codegen.Decoder) []Media {
	n := dec.Len()
	if n == -1 {
		return nil
	}
	res := make([]Media, n)
	for i := 0; i < n; i++ {
		(&res[i]).WeaverUnmarshal(dec)
	}
	return res
}

func serviceweaver_enc_slice_Url_b557e127(enc *codegen.Encoder, arg []Url) {
	if arg == nil {
		enc.Len(-1)
		return
	}
	enc.Len(len(arg))
	for i := 0; i < len(arg); i++ {
		(arg[i]).WeaverMarshal(enc)
	}
}

func serviceweaver_dec_slice_Url_b557e127(dec *codegen.Decoder) []Url {
	n := dec.Len()
	if n == -1 {
		return nil
	}
	res := make([]Url, n)
	for i := 0; i < n; i++ {
		(&res[i]).WeaverUnmarshal(dec)
	}
	return res
}

var _ codegen.AutoMarshal = (*TextServiceReturn)(nil)

type __is_TextServiceReturn[T ~struct {
	weaver.AutoMarshal
	Text          string
	User_mentions []UserMention
	Urls          []Url
}] struct{}

var _ __is_TextServiceReturn[TextServiceReturn]

func (x *TextServiceReturn) WeaverMarshal(enc *codegen.Encoder) {
	if x == nil {
		panic(fmt.Errorf("TextServiceReturn.WeaverMarshal: nil receiver"))
	}
	enc.String(x.Text)
	serviceweaver_enc_slice_UserMention_4c1e0334(enc, x.User_mentions)
	serviceweaver_enc_slice_Url_b557e127(enc, x.Urls)
}

func (x *TextServiceReturn) WeaverUnmarshal(dec *codegen.Decoder) {
	if x == nil {
		panic(fmt.Errorf("TextServiceReturn.WeaverUnmarshal: nil receiver"))
	}
	x.Text = dec.String()
	x.User_mentions = serviceweaver_dec_slice_UserMention_4c1e0334(dec)
	x.Urls = serviceweaver_dec_slice_Url_b557e127(dec)
}

var _ codegen.AutoMarshal = (*Url)(nil)

type __is_Url[T ~struct {
	weaver.AutoMarshal
	ShortenedUrl string
	ExpandedUrl  string
}] struct{}

var _ __is_Url[Url]

func (x *Url) WeaverMarshal(enc *codegen.Encoder) {
	if x == nil {
		panic(fmt.Errorf("Url.WeaverMarshal: nil receiver"))
	}
	enc.String(x.ShortenedUrl)
	enc.String(x.ExpandedUrl)
}

func (x *Url) WeaverUnmarshal(dec *codegen.Decoder) {
	if x == nil {
		panic(fmt.Errorf("Url.WeaverUnmarshal: nil receiver"))
	}
	x.ShortenedUrl = dec.String()
	x.ExpandedUrl = dec.String()
}

var _ codegen.AutoMarshal = (*UserMention)(nil)

type __is_UserMention[T ~struct {
	weaver.AutoMarshal
	UserId   int64
	Username string
}] struct{}

var _ __is_UserMention[UserMention]

func (x *UserMention) WeaverMarshal(enc *codegen.Encoder) {
	if x == nil {
		panic(fmt.Errorf("UserMention.WeaverMarshal: nil receiver"))
	}
	enc.Int64(x.UserId)
	enc.String(x.Username)
}

func (x *UserMention) WeaverUnmarshal(dec *codegen.Decoder) {
	if x == nil {
		panic(fmt.Errorf("UserMention.WeaverUnmarshal: nil receiver"))
	}
	x.UserId = dec.Int64()
	x.Username = dec.String()
}

var _ codegen.AutoMarshal = (*UserProfile)(nil)

type __is_UserProfile[T ~struct {
	weaver.AutoMarshal
	UserId         int64
	FirstName      string
	LastName       string
	Salt           string
	PasswordHashed string
}] struct{}

var _ __is_UserProfile[UserProfile]

func (x *UserProfile) WeaverMarshal(enc *codegen.Encoder) {
	if x == nil {
		panic(fmt.Errorf("UserProfile.WeaverMarshal: nil receiver"))
	}
	enc.Int64(x.UserId)
	enc.String(x.FirstName)
	enc.String(x.LastName)
	enc.String(x.Salt)
	enc.String(x.PasswordHashed)
}

func (x *UserProfile) WeaverUnmarshal(dec *codegen.Decoder) {
	if x == nil {
		panic(fmt.Errorf("UserProfile.WeaverUnmarshal: nil receiver"))
	}
	x.UserId = dec.Int64()
	x.FirstName = dec.String()
	x.LastName = dec.String()
	x.Salt = dec.String()
	x.PasswordHashed = dec.String()
}

// Router methods.

// _hashIStorage returns a 64 bit hash of the provided value.
func _hashIStorage(r string) uint64 {
	var h codegen.Hasher
	h.WriteString(string(r))
	return h.Sum64()
}

// _orderedCodeIStorage returns an order-preserving serialization of the provided value.
func _orderedCodeIStorage(r string) codegen.OrderedCode {
	var enc codegen.OrderedEncoder
	enc.WriteString(string(r))
	return enc.Encode()
}

// Encoding/decoding implementations.

func serviceweaver_enc_slice_int64_a8f7f092(enc *codegen.Encoder, arg []int64) {
	if arg == nil {
		enc.Len(-1)
		return
	}
	enc.Len(len(arg))
	for i := 0; i < len(arg); i++ {
		enc.Int64(arg[i])
	}
}

func serviceweaver_dec_slice_int64_a8f7f092(dec *codegen.Decoder) []int64 {
	n := dec.Len()
	if n == -1 {
		return nil
	}
	res := make([]int64, n)
	for i := 0; i < n; i++ {
		res[i] = dec.Int64()
	}
	return res
}

func serviceweaver_enc_slice_string_4af10117(enc *codegen.Encoder, arg []string) {
	if arg == nil {
		enc.Len(-1)
		return
	}
	enc.Len(len(arg))
	for i := 0; i < len(arg); i++ {
		enc.String(arg[i])
	}
}

func serviceweaver_dec_slice_string_4af10117(dec *codegen.Decoder) []string {
	n := dec.Len()
	if n == -1 {
		return nil
	}
	res := make([]string, n)
	for i := 0; i < n; i++ {
		res[i] = dec.String()
	}
	return res
}

func serviceweaver_enc_slice_Post_92420d4c(enc *codegen.Encoder, arg []Post) {
	if arg == nil {
		enc.Len(-1)
		return
	}
	enc.Len(len(arg))
	for i := 0; i < len(arg); i++ {
		(arg[i]).WeaverMarshal(enc)
	}
}

func serviceweaver_dec_slice_Post_92420d4c(dec *codegen.Decoder) []Post {
	n := dec.Len()
	if n == -1 {
		return nil
	}
	res := make([]Post, n)
	for i := 0; i < n; i++ {
		(&res[i]).WeaverUnmarshal(dec)
	}
	return res
}

func serviceweaver_enc_map_int64_bool_7caa5f14(enc *codegen.Encoder, arg map[int64]bool) {
	if arg == nil {
		enc.Len(-1)
		return
	}
	enc.Len(len(arg))
	for k, v := range arg {
		enc.Int64(k)
		enc.Bool(v)
	}
}

func serviceweaver_dec_map_int64_bool_7caa5f14(dec *codegen.Decoder) map[int64]bool {
	n := dec.Len()
	if n == -1 {
		return nil
	}
	res := make(map[int64]bool, n)
	var k int64
	var v bool
	for i := 0; i < n; i++ {
		k = dec.Int64()
		v = dec.Bool()
		res[k] = v
	}
	return res
}

// Size implementations.

// serviceweaver_size_UserProfile_fea8d204 returns the size (in bytes) of the serialization
// of the provided type.
func serviceweaver_size_UserProfile_fea8d204(x *UserProfile) int {
	size := 0
	size += 0
	size += 8
	size += (4 + len(x.FirstName))
	size += (4 + len(x.LastName))
	size += (4 + len(x.Salt))
	size += (4 + len(x.PasswordHashed))
	return size
}
